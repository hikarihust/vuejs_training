<VirtualHost *:80>
  ServerAdmin proj_news.xyz
  DocumentRoot "C:/xampp/htdocs/vuejs"
  ServerName proj_news.xyz
  ErrorLog "logs/proj_news.xyz-error.log"
  CustomLog "logs/proj_news.xyz-access.log" common
</VirtualHost>

========================================== Cài đặt môi trường ==========================================

Cài đặt nodeJs. Khi cài đặt nodeJs thì sẽ có sẵn npm
Trước khi cài đặt thì kiểm tra xem nodeJs đã được cài đặt hay chưa bằng cách dùng câu lệnh node -v, npm -v
	trên PowerShell
Git -> Để Deploy mã nguồn lên server(sử dụng các hosting free)

========================================== Vuejs cơ bản ==========================================
Tìm hiểu về Vue Instance:
  Nghiên cứu cách tích hợp Vuejs vào trong 1 phần dự án đã tồn 
  Tích hợp Vuejs
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.18/vue.min.js"></script>
  Vue Instance là 1 thực thể Vue hay đối tượng Vue dùng để quản lý một thành phần trong trang web
  Khi tạo 1 Instance thì cần truyền vào 1 đối tượng để khai báo các thông tin liên quan như là: Đối tượng Instance
    đó quản lý thành phần nào
  Data and Methods:
    Data: Dữ liệu giành cho thành phần mà nó quản lý
  
Ràng buộc dữ liệu một chiều với Data Binding:
  Keywords: Template Syntax
  Đối với js khi sử dụng trong Vuejs sẽ có 1 số chú ý khi viết dấu {{}} đó là chỉ sử dụng được các biểu thức đơn giản
    như cộng trừ nhân chia, toán tử 3 ngôi thay thế cho biểu thức điều kiện, hay là sủ dụng các Methods của js cung
    cấp sẵn;
    {{ number + 1 }}
    {{ ok ? 'YES' : 'NO' }}
    {{ message.split('').reverse().join('') }}
  Không sử dụng được trong các trường hợp như là khai báo biến, hay sử dụng các câu lệnh điều kiện if-else

Sử dụng v on xử lí sự kiện người dùng: Cách sử dụng và cách khai báo Event trong Vuejs

Cách sử dụng Event Modifiers:
  stop và prevent
  Có thể viết bằng Javascript thông thường, tuy nhiên thì nếu sử dụng Event Modifiers thì sẽ giảm được 1 số đoạn code 
    thường lặp đi lặp lại trong quá trình sử lý
  Khi làm ứng dụng 1 trang Single Application thì Form cần phải được xử lý riêng, khi người dùng nhấn nút submit thì
    không cho trang chuyển hướng đến trang khác mà sẽ tạm dừng ở đó, sử lý dữ liệu trực tiếp bằng js sau đó sử dụng các
    công cụ khác để tương tác với server và gửi dữ liệu sang server.
  Để khi submit form mà nó không chuyển trang đi thì ở trong js có 1 khác niệm rất quen thuộc đó là preventdefault
  stopPropagation: Ngăn chặn sự kiện của phần tử con lan tỏa ra phần tử cha
Key Modifiers: Thường sử dụng với các ô input
  Chẳng hạn như trong form có input submit, thì trong trường hợp này khi mình nhập vào form rồi nhấn Enter thì nó sẽ chạy
  Thay cho việc dùng keycode để kiểm tra nhấn nút Enter thì có thể viết:
    <input v-on:keyup.enter="submit">
  Cũng kiểm tra tương tự thì có thể kiểm tra việc nhấn 
  enter, tab, delete (captures both “Delete” and “Backspace” keys), esc, space, up, down, left, right...
Tìm hiểu về Computed:
  Đối với Template của Vuejs {{}} thì sử dụng khá thuận lợi, tuy nhiên chỉ nên dùng trong các trường hợp mà biểu thức
    của mình là đơn giản, đối với các trường hợp mà biểu thức phức tạp thì không nên đặt ở phía Template mà nên sử dụng các
    thuộc tính hay method để thực hiện các logic
  computed là 1 thuộc tính trong object truyền vào đối tượng Vue. Computed có nhiều thuộc tính bên trong mà mỗi 1 thuộc
    tính là 1 function, các function này được tính toán dựa vào các dữ liệu có sẵn
    Ở đây thì nếu dùng method thì khi gọi đến ở Template thì cần phải có lời gọi hàm đi cùng nghĩa là cần có dấu ()
  Sự khác của method so với computed đó là khi sử dụng method thì phát sinh ra vấn đề đó là sô s lượng method sẽ được run 
    không mong muốn, có nghĩa là sẽ chạy bị thừa. Nếu mà khi thao tác với dữ liệu lớn thì sẽ làm giảm tốc độ chương trình.
    Do đó trong trường hợp này sẽ sử dụng computed
    <button v-on:click="a++"> A=A+1 </button>
    <button v-on:click="b++"> B=B+1 </button>
    <p>Number + A = {{ addA() }}</p>
    <p>Number + B = {{ addB() }}</p>
  Giải thích:
    Khi sử dụng method thì trong Template sẽ dùng lời gọi hàm, khi có bất kỳ 1 sự thay đổi nào thì Vuejs nó sẽ render lại
      Template do đó khi gặp lời gọi hàm nào thì nó sẽ luôn luôn chạy hàm đó.
    Đối với computed thì tuy khai báo giống như 1 hàm tuy nhiên thì nó sẽ được lưu vào đối tượng Vue, và hàm này chỉ được
      thực thi khi mà dữ liệu trong hàm đó có sự thay đổi
  => method thì sử dụng khi tính toán dữ liệu nó không dành riêng cho data, computed được dùng dựa trên dữ liệu của đối
    tượng Vue
Ràng buộc dữ liệu 2 chiều:
  <div id="app">
      <h1>FirstName = {{ firstName }}</h1>
      <input v-on:keyup="handleKeyUp" type="text" placeholder="Nhap firstName">
  </div>
  Dàng buộc dữ liệu 2 chiều được thể hiện ở chỗ dàng buộc biến trong data của mình vào trong ô input và đồng thời ô input
    nó sẽ dàng buộc ngược lại dữ liệu của mình khi người dùng nhập vào
  Vue cung cấp 1 chỉ thị để có thể làm việc này nhanh hơn đó là v-model

Ràng buộc Class bằng VueJs:
  Một phần thường xuyên xuất hiện trong các yêu cầu khi sử dụng Javascript thuần tương tác với cấu trúc Dom đó là việc thay
    đổi Class và thay đổi Style của 1 phần tử
  Class hay Style thì bản chất nó cũng là 1 Attribute, nó là thuộc tính của phần tử Html
  Đối với 1 phần tử thì có thể có nhiều Class, Trong VueJs thì dùng 1 đối tượng để quản lý các class

Ràng buộc Style cho phần tử:
  Đối với style thì có 1 số lưu ý riêng khi tương tác với 1 số phần tử đặc biệt như:
    <div style="background-image: url('https://cdn.pixabay.com/photo/2017/03/02/08/58/background-texture-2110724__340.jpg')">

Render Template dùng biểu thức điều kiện:
  Dùng để render ra các phần tử Html nào đó theo điều kiện nhất định. Điều kiện chính là biểu thức của Javascript nó có thể theo
    biến lưu trong data hoặc biến được tính toán trong computed
  Bên cạnh việc sử dụng v-if, v-else thì có thể dùng v-show
  Khi dùng v-show thì các phần tử Html đều tồn tại trong cấu trúc DOM nó chỉ ẩn đi bằng style display:none Còn đối với v-if và v-else 
    thì nó sẽ remove luôn đi phần tử Html
Render Template dùng vòng lặp trong VueJs:
  Đối với vòng lặp để quản lý tốt được vị trí và thứ tự của các phần tử thì nên cung cấp cho VueJs 1 key để để phân biệt các phần tử 
    với nhau để phục vụ các logic như sắp xếp các phần tử, sort, filter... thì dùng đến 1 thuôc tính đó là key

Lưu ý về Loop và Condition trong VueJS: Tìm hiểu độ ưu tiên của v-for so với v-if khi sử dụng chúng chung với nhau
  Xét về độ ưu tiên thì vòng v-for có độ ưu tiên cao hơn v-if
    <div class="user" v-for="user in arrUser" v-if="user.isActive">{{ user.email }}</div>
  Đối với trường hợp này nên tạo ra 1 computed được tính toán dựa trên thông số isActive để lọc ra những user nào có trạng thái là
    active

Lưu ý quan trọng về Array và Object trong VueJs: Vấn đề quan trọng và nó thường gây ra lỗi khi ta tương tác với VueJS thông qua object
  và array
  Đối với 1 số hàm có sãn của array như: push(), pop(), shift(), unshift(), splice(), sort(), reverse()
    -> Khi sử dụng hàm này để thêm, sửa, xóa các phần tử ở trong thì hệ thống phản ứng sẽ hoạt động và render lại. Nếu không thực hiện
    bằng cách sử dụng các phương thức này mà gán theo các cách thông thường thì các giá trị thay đổi không được render lại trên view
  Muốn thực hiện thay đổi theo cách thông thường như vậy thì dùng 1 hàm có sẵn của VueJs đó là $set()
    app;
      Vue {_uid: 0, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: Vue, …}
    app.arrNumber;  
      (6) [1, 2, 3, 4, 5, 6, __ob__: Observer]
    app.arrNumber.push(7);
      7
    app.arrNumber
      (7) [1, 2, 3, 4, 5, 6, 7, __ob__: Observer]
    app.arrNumber[7]
      undefined
    app.arrNumber[7]=2000;
      2000
    app.arrNumber[0]=2000;
      2000
    app.$set(app.arrNumber, 0, 3000);
      3000
  Trong trường hợp thay đổi thành 1 object mới thì ok bởi vì địa chỉ cũng thay đổi, thì lúc này hệ thống phản ứng sẽ giám sát địa chỉ đó
    app.objScore;
    {__ob__: Observer}math: 7.5__ob__: Observerdep: Dep {id: 4, subs: Array(1)}value: {__ob__: Observer}vmCount: 0__proto__: Objectget math: ƒ reactiveGetter()set math: ƒ reactiveSetter(newVal)__proto__: Object
    app.objScore.english=10;
    10
    app.objScore = {math: 7, english:8}
    {__ob__: Observer}
  Thêm 1 phần tử bằng cách dùng $set -> sẽ được hệ thống phản ứng giám sát sự thay đổi
    app.$set(app.objScore, 'physics', 8);
      8

                                =======================================================================
                                              Demo bài tập thực hành tổng hợp số 01

Phân tích data và Xử lí Price
Xử lý Change Color
  Xử lý sự kiện khi người dùng Click vào màu sắc nhất định
  Thường thì khi sử dụng vòng lặp for thì sẽ dùng đến key gắn vào cho các phần tử Html
Sử dụng v html trong Vue
  Render ra Html danh sách đặc tính của sản phẩm
  Render ra được mã nguồn Html trong 1 đoạn text

                                =======================================================================
Giới thiệu và cài đặt Vue CLI
  Cách cài đặt 1 cấu trúc thư mục cơ bản để xây dựng 1 dự án theo mô hình Single Page Application
  Dùng để xây dựng nhanh 1 cấu trúc thư mục để quản lý mã nguồn
  CLI: Command Line Interface
  Keywords: vuejs Template webpack -> https://github.com/vuejs-templates/webpack
  Để chạy các câu lệnh để có thể cài đặt thì cần phải đảm bảo đã cài đặt nodeJs và npm
    $ npm install -g vue-cli: -g là chữ viết tắt của global, cài đặt vue-cli ở trong tầm vực global, mình ó thể sử 
      dụng nó ở bất kỳ nơi nào trong máy tính để tạo ra 1 cấu truc thư mục mẫu
    $ vue init webpack my-project: my-project chính là tên của dự án
      $ vue init webpack-simple helloVueJs
      ? Project name (helloVueJs) hello
      ? Project name hello
      ? Project description (A Vue.js project)
      ? Project description A Vue.js project
      ? Author (vudinhquang <vudinhquangk53@gmail.com>)
      ? Author vudinhquang <vudinhquangk53@gmail.com>
      ? License (MIT)
      ? License MIT
      ? Use sass? (y/N) n
      ? Use sass? No
        vue-cli · Generated "helloVueJs".
        To get started:
          cd helloVueJs
          npm install
            Cài đặt các thư viện khác mà nó sử dụng trong VueJS. Coi trong package.json, nó khai báo 
              tất cả các thư viện phụ thuộc vào bên ngoài
            Sau khi chạy câu lệnh này xong thì trong thư mục của mình có thêm thư mục là node_modules trong đó
              chứa tất cả các thư viện mà chúng ta có sử dụng
          npm run dev
            Câu lệnh này sẽ sinh ra 1 server ảo: http://localhost:8081/
    $ cd my-project
    $ npm install
    $ npm run dev
Cấu trúc Project, tìm hiểu Webpack và Babel
  Tìm hiểu về 1 số thành phần được tạo ra sau khi cài đặt cấu trúc thư mục
    package.json: Là nơi khai báo các thư viện, module ở bên ngoài mà mình sử dụng trong project
  Có 2 môi trường:
    Development: Là môi trường dành cho lập trình viên
      "devDependencies": {
        "babel-core": "^6.26.0",
        "babel-loader": "^7.1.2",
        "babel-preset-env": "^1.6.0",
        "babel-preset-stage-3": "^6.24.1",
        "cross-env": "^5.0.5",
        "css-loader": "^0.28.7",
        "file-loader": "^1.1.4",
        "vue-loader": "^13.0.5",
        "vue-template-compiler": "^2.4.4",
        "webpack": "^3.6.0",
        "webpack-dev-server": "^2.9.1"
      }
      -> Dùng trong quá trình lập trình
        Babel là 1 trình biên dịch của Javascript
        ES6:
          let name = 'join';
          const age = 28;
          let str = `My name is ${name}`;
          class Person {
            constructor(name = '', age = 28) {
              this.name = name;
              this.age = age;
            }
          }
          var arr1 = [1, 2, 3];
          var arr2 = ['abc', 'def'];
          arr = [...arr1, ...arr2];
    Production: Public ra cho user sử dụng
      "dependencies": {
        "vue": "^2.5.11"
      }
      -> Dùng xuyên suốt trong quá trình user dùng trang web của mình
  Webpack: Công cụ giúp đóng gói code, đóng gói mã nguồn
    Khi đẩy code ở dạng môi trường Production thì sẽ build ra bằng câu lệnh: npm run build lúc này sẽ sinh ra 1 
      thư mục nữa chính là thư mục chứa file Javascript cuối cùng đã được đóng gói. Để đóng gói được thì cần phải có
      webpack
    Lệnh: $ npm run build

Cấu trúc Project và Cấu hình cơ bản Webpack: Cấu hình lại thông tin cơ bản để phục vụ quá trình lập trình
  https://webpack.js.org: Xem hướng dẫn cách config
  index.html là file được chạy đầu tiên, trong đó có 1 đối tượng <div id="app"></div>, đối tượng Vue để quản lý app đó
    là nằm trong main.js thuộc folder src
  import Vue from 'vue' thực hiện import thư viện vue từ bên ngoài vào, thư viện này được khai báo ở trong package.json
    "dependencies": {
      "vue": "^2.5.11"
    },
   App from './App.vue'
    Trong đây là nơi khai báo toàn bộ mã nguồn, có 3 thành phần chính: template, script(Javascript), style để viết Css
    script:
      export default {
        name: 'app',
        data () {
          return {
            msg: 'Welcome to Your Vue.js App'
          }
        }
      }
    -> main.js là nơi sẽ import
    Mỗi thành phần trong Web tương ứng với mỗi component -> Tương ứng với 1 file *.vue
  Extension: 
    Keywords: Vue -> Vetur, khi cài đặt xong thì sẽ xem được cú pháp của App.vue dễ nhìn hơn
  Webpack là công cụ để đóng gói, do đó khi build thì có thể cấu hình lại nó chẳng hạn như vị trí index.html, tên thư mục
    có để đổi từ dist sang tên khác, hay vị trí của file ảnh logo.png cũng vậy
    -> webpack.config.js Là nơi để cấu hình webpack, để khai báo các thông tin liên quan đến trang web
    entry: './src/main.js', main.js là file nó sẽ chạy lần đầu tiên
    output: {
      path: path.resolve(__dirname, './dist'),
      publicPath: '/dist/',
      filename: 'build.js'
    },
      -> Đóng gói sẽ xuất ra ở đâu
      publicPath: '/dist/' là đường dẫn sẽ đóng gói ra bên ngoài
  
  Sau khi config xong thì gõ lệnh: npm run build, chạy xong câu lệnh này thì sẽ sinh ra được thư mục mới(dist), có thể thay
    đổi tên tùy ý
  loader: 'file-loader', là công cụ dùng để quản lý hình ảnh và đóng gói hình ảnh
    "devDependencies": {
      "babel-core": "^6.26.0",
      "babel-loader": "^7.1.2",
      "babel-preset-env": "^1.6.0",
      "babel-preset-stage-3": "^6.24.1",
      "cross-env": "^5.0.5",
      "css-loader": "^0.28.7",
      "file-loader": "^1.1.4",
      "vue-loader": "^13.0.5",            -> Để thông báo vue.js là file hợp nệ
      "vue-template-compiler": "^2.4.4",
      "webpack": "^3.6.0",
      "webpack-dev-server": "^2.9.1"
    }
    https://webpack.js.org/loaders/file-loader/#root
    options:
      name: '[name].[ext]?[hash]'
        ->
        name: function(file) {
          return '/images/[contenthash].[ext]';
        }

Tìm hiểu Component và cách tạo trong Vue: Cách xây dựng 1 component mới kết nối các component lại với nhau để tạo ra một 
  trang web hoàn chỉnh
  Mỗi component chứa đựng 1 thành phần trong trang web, mỗi component được quản lý bởi 1 file *.vue, do đó thì khi mà mình
    muốn tạo ra bao nhiêu component thì tạo ra bấy nhiêu file *.vue
  Cách xây dựng component thì nó sẽ có cấu trúc giống như cấu trúc html
    App
      Header 
      ListProduct
        Product
        Product
        Product
        Product
      Footer
  Mỗi Component có cấu trúc 3 phần
    template: Để viết mã nguồn html
    script: export default ra 1 object, object này giống với đối tượng Vue
    style: Nếu như component có CSS riêng thì sẽ viết ở đây
  Khi muốn sử dụng 1 component ở trong 1 component khác thì ngoài việc phải import vào thì cần phải đăng ký 
    trong component mà nó sử dụng
      Keywords: Single File Components
        components: {
          OtherComponent
        }

Cài đặt mã nguồn và tổ chức Component lồng nhau
  Khi chia sẻ các source code giữa các máy tính với nhau thì sẽ không chia sẻ tập tin node_modules mà thư mục
    này chỉ được sinh ra trong nội bộ máy tính của mình mà thôi.
    npm install -> node_modules
    public/  -> Đóng gói khi đẩy code lên môi trường Product để cho người dùng sử dụng

Tìm hiểu Props Down trong Vue
  Keywords: props
  Cách để truyền dữ liệu giữa các component với nhau
  props Là những Data, những dữ liệu mà mình sẽ truyền từ component cha vào component con
    -> Sử dụng cú pháp giống với thuộc tính, thuộc tính này là thuộc tính mà mình tự đặt ra -> Ràng buộc thuộc
      tính -> Sử dụng chỉ thị v-bind để ràng buộc dữ liệu vào trong thuộc tính này
  Khi khai báo sử dụng props rồi thì sử dụng nó giống như 1 data thông thường
  Đối với props khi không quy định gì cả thì có nghĩa là có thể truyền vào hoặc không và khi đó cần phải định 
    nghĩa dữ liệu mặc định
  Giả sử không truyền props thì cũng ko
  Demo: App chứa các thông tin: title, listArray[]
        title truyền vào cho CompHeader và CompFooter, truyền listUser vào cho ListUser
          Trong ListUser Component nhận được mảng giá trị ListUser truyền từ App sẽ tiếp duyệt từng user và truyền
            vào User Component
    -> Toàn bộ dữ liệu được quản lý ở App Component

Tìm hiểu Event Up trong Vue:
  Tìm hiểu cách truyền 1 thông điệp từ component con ra component cha để gửi thông báo muốn thay đổi dữ liệu từ component 
    cha
  Keywords: Custom Event trong Vuejs
  Tìm cách tương tác với dữ liệu
  Demo: 
    App.vue:
      <template>
        <div id="app">
          <!-- <CompHeader></CompHeader>
          <CompHeader /> -->
          <!-- <comp-header v-bind:titleHeader="title"/> -->
          <div class="container">
            <button v-on:click="title = 'Học lập trình Vuejs'">Thay đổi title từ Component App.vue</button>
            <comp-header v-bind:title="title"/>
            <list-user v-bind:listUser="listUser"/>
            <comp-footer v-bind:title="title"/>
          </div>
          <!-- <comp-footer/> -->
        </div>
      </template>
    Tại App.vue thì khi nhấn vào buttom thì thực hiện thay đổi title -> Khi đó thì hệ thống phản ứng sẽ hoạt động
    -> Component Header và Component Footer đều nhận được sự thay đổi đó
    Phần thực hiện này nó liên quan đến Props Down. Props là dữ liệu của cha truyền vào nên nó truyền xuống tất cả các 
      component con bên trong có sử dụng -> tự động phản ứng lại, render lại giao diện bất kỳ khi nào component cha(quản
      lý title) thực hiện thay đổi title.
  Trong thực tế có thể có nhu cầu phức tạp hơn đó là việc click thay đổi title ở trong Header Component. Trong trường
    hợp này thì không được phép thay đổi props trực tiếp từ trong component con. Về nguyên tắc thì props được truyền 
    từ component cha nên chỉ component mới có thể thay đổi
  Đây là 1 phần rất quan trọng bởi vì khi làm các dự án lớn thì sẽ lồng rất nhiều component lại với nhau, để tương tác giữa
    các component đó thì phải biết cách Event Up và Props Down
  Props Down -> Dùng để truyền dữ liệu từ cha vào con -> Thằng con chỉ được dùng thôi chứ không được thay đổi trực tiếp
    Component nào nắm giữ data thì chỉ có component đó có thể thay đổi thôi. title đang do App.vue nắm giữ nên chỉ App.vue
      mới có thể thay đổi thôi
  Event Up -> Truyền thông điệp(sự kiện) để thông báo cho component cha biết là nó muốn thay đổi dữ liệu -> Nhiệm vụ 
    của component cha là nhận được thông điệp và tiến hành thay đổi data.
    Việc gửi thông báo đó nó là mình sẽ tạo ra 1 sự kiện
    -> Phần này liên quan đến Custom Event trong Vuejs

    click -> Là sự kiện có sẵn trong VueJs, để khai báo click thì sử dụng từ khóa v-on:click="changeTitle"
      -> Phân dã ra làm nhiều thành phần nhỏ:
        'click' -> Tên của sự kiện
        'changeTitle' -> Hàm xử lý khi sự kiện được kích hoạt, có nhiều dạng sự kiện khác nhau. Đối với sự kiện click thì
          nó sẽ được kích hoạt khi người dùng click
  Tự tạo ra 1 sự kiện mới và tự đặt tên cho sự kiện đó, và định nghĩa khi nào nó được kíck hoạt, ở đây nó được kích hoạt
    thông qua những đoạn code(các sự kiện có sãn trong Vuejs thì nó được kích hoạt thông qua sự tương tác của người dùng)
    -> Để kích hoạt được thì dùng từ khóa là $emit -> gọi ở trong component con
  Khi dùng các sự kiện mặc định như click... thì nó đã truyền sẵn cho mình 1 biến $event, tuy nhiên khi tự tạo ra 1 sự kiện
    mới thì dữ liệu đó sẽ truyền vào tham số thứ 2 của $emit(); và e này là 1 đối tượng mình tự tạo ra(các sự kiện như
    click thì là do Javascript tạo)
  Demo Xóa user: Tạo thêm nút nhấn cho các user có chức năng xóa user
    Khi click vào nút nhấn delete thì cần phải truyền thông điệp ra ngoài App để nó có thể xóa được 1 phần tử nhất định
    Trong trường hợp này thì cấp độ nâng cao hơn trường hợp thay đổi title tại vì user không phải được gọi trực tiếp từ App
      Mà User component lại được gọi từ ListUser component
    Xét về mô hình truyền event:
      App -> truyền arrUser vào cho ListUser, tại đây ListUser component sẽ chạy vòng for để render ra từng user -> truyền 
        vào User component.
      Như vậy thì tại User component truyền event thông báo ra cho ListUser, bởi vì ListUser không phải component nắm giữ
        arrUser mà do App component nắm giữ. Do đó ListUser này cũng không được quyền thay đổi arrUser -> Tiếp tục truyền 
        tiếp event thêm 1 lần nữa ra ngoài App component, công việc truyền này chỉ thực hiện khi nó nhận được thông báo từ
        User component -> Thực hiện xóa tại App component
      splice(): Dùng để xóa đi 1 phần tử trong mảng
        array.splice(index, howmany, item1, ....., itemX)
          index: Vị trí xóa từ phần tử nào
          howmany: Xóa bao nhiêu phần tử
        Trả về danh sách đã xóa 

Sử dụng Ref trong Vue(Reference)
  Reference là 1 biến dùng để tham chiếu đến các phần tử html mà mình muốn sử dụng nó cho 1 mục đích của Javascript
  <input type="file"> -> Rất khó để có thể thay đổi được giao diện của nó, nên thông thường ở trong Javascript thuần người
    ta thường tạo ra 1 bản sao của nó bằng 1 html(buttom) khác dễ code hơn, dễ viết css hơn, dễ làm cho giao diện hơn, khi người ta
    bắt sự kiện click để có thể chọn 1 file từ máy tính thì người ta sẽ bắt sự kiện click thông qua nút(buttom) nhấn đó, thực ra nút 
    input type="file" này thực sự đã ẩn bên cạnh rồi
  Để chọn được avatar thông qua nút mà mình đã tạo bằng html(buttom) thì lúc này sẽ sử dụng Reference
  handleClickInputFile() có chức năng gọi sự kiện click vào ô input, thay vì người dùng trực click vào nút này thì mình sẽ click nó
    bằng code, truy cập vào input type="file" thông qua biến toàn cục refs của ô input đó.
    Do đó lúc này khi click vào buttom thì mình có thể chọn được avatar mặc dù đã ẩn input type="file"

Tìm hiểu Slot và bài tập ứng dụng: Cách sử dụng slot trong VueJs thông qua các ứng dụng thực tế
  Đối với props thì nó chỉ truyền vào cho component con những giá trị với kiểu dữ liệu cơ bản như string, number, array, object
  Khi muốn truyền 1 cấu trúc html vào cho component con thì việc này Slot có thể làm được
  Slot được sử dụng trong trường hợp mình muốn kế thừa 1 phần nào đó của component
  Demo: Ứng dụng các slot trong thực tế dùng để kế thừa lại và tăng tính sử dụng lại của 1 component
    Xây dựng 1 component để hiện thực 1 tab, phía trên là tiêu đề của tab nhận string của component cha truyền vào và 1 
      icon -> tiêu đề này thì có thể dùng props để truyền dữ liệu từ component cha sang component con
      Trong component con thì nội dung được kế thừa từ component cha được đặt ở vị trí của cặp thẻ <slot></slot>
    Phần dưới là phần dành cho tab gồm có danh sách nhiều tab, phía dưới là nội dung của tab đó. Khi click vào tab nào thì nội
      dung của tab đó sẽ được hiển thị
    Icon: ionicons
      https://ionicons.com/usage
    Tùy vào trường hợp mà sẽ hiển thị lên nội dung của tab tương ứng -> do đó cần có 1 biến nào đó để nhận diện hiện tại nó
      đang show tab nào
    Xử lý sự kiện click, khi click vào tab nào thì sẽ hiển thị tab tương ứng
    Khi tab nào được active thì tab đó có thêm class là active -> dàng buộc dữ liệu vào class
  
Tìm hiểu về Life Cycle: Vòng đời của 1 đối tượng Vue kể từ khi nó được khởi tạo cho đến khi nó được remove khỏi cấu trúc DOM
  https://vuejs.org/v2/guide/instance.html#Lifecycle-Diagram
  VueJs đã tạo sẵn 1 số function như: beforeCreate(), created(), beforeMount(), mounted(), beforeUpdate(), updated(), 
    beforeDestroy(), destroyed()
  Các function này VueJs tạo sẵn cho ta chèn vào giữa quá trình hoạt động của nó để có thể sinh ra các mã code trong đó xen
    giữa vào quá trình hoạt động từ trên xuống dưới của 1 đối tượng Vue
  Thứ tự run của các hàm này:
    beforeCreate() -> created() -> beforeMount() -> mounted
  beforeCreate(): Được chạy khi đối tượng Vue được khởi tạo và bắt đầu khởi tạo ra được vòng đời, Trước khi hệ thống phản
    ứng hoạt động
    Do đó tại function này thì khi truy xuất vào các data của component thì sẽ trả về là undefined bởi vì ngay tại thời điểm
      đó đối tượng Vue chưa xây dựng hệ thống phản ứng mà kể từ hàm created() trở đi thì có thể truy xuất được vào tất cả các
      data của component
  created(): Khi đối tượng Vue đã xây dựng xong hệ thống phản ứng, lúc đó toàn bộ dữ liệu có thể truy xuất được rồi thì sẽ
    thực thi hàm created()
    Là nơi thường truyền các đoạn code như gọi API, Call Ajax để lấy dữ liệu từ server về
  Việc compile(biên dịch) template html ra cấu trúc DOM, cho đến hàm mounted() thì toàn bộ cấu trúc DOM mới hiển thị ra Html
    Do đó thì cho đến đi vào hàm mounted() thì mới có thể truy xuất được vào cấu trúc DOM
    Do đó thì chỉ trong hàm mounted() trở đi mình mới có thể dùng các thư viện liên quan đến jQuery, Javascript thông thường
      để truy xuất DOM để thực hiện hành động nào đó tương tác với cấu trúc DOM
  beforeDestroy() và destroyed() được chạy khi đối tượng Vue bị hủy bỏ
  beforeUpdate() và updated() được chạy khi có bất kỳ 1 sự thay đổi nào đó về dữ liệu. Hàm beforeUpdate() được chạy trước, rồi
    sau đó mới chạy updated()
    Được dùng để bắt việc có sự thay đổi dữ liệu, có thể ứng dụng viết sử lý cho việc sau khi thay đổi dữ liệu xong thì 
    sẽ làm gì tiếp...
  -> Hàm hay được sử dụng đó là created() và mounted()

========================================== Xây dựng Game đổ xúc xắc ==========================================

Phân tích kĩ thuật và dữ liệu
  <div class="spinner dice-3"> Dùng để thay đổi xúc xắc bằng cách thay đổi số, đối với vấn đề này thì có thể sử dụng việc dàng
    buộc class trong VueJs -> Ramdom ra 1 con số rồi truyền vào class trên dice-*
  Active: Khi đến lượt người nào chơi thì người đó sẽ được active(được thêm class là active), đến khi có 1 người nào chiến thắng
    thì class active sẽ được thay bằng class winner và tên người chơi cũng được sửa lại là Winner
  Các hành động: Có các hành động đó là new game, rolldice, hold
  Các dữ liệu cần lưu: Lưu thông tin điểm chính thức, điểm tạm thời. Điểm tạm thời là điểm được cộng dồn mỗi lần người dùng đó
    xoay xúc xắc. Khi người dùng nhấn vào nút lấy điểm(hold) thì lúc đó điểm tạm thời đó mới được cộng vào trong điểm chính thức.
    Khi xoay xúc xắc thì phải có các con số để đại diện cho nó.
    Ngoài ra thì cần phải bắt thêm 1 sự kiện nữa đó là khi nào thì người ta bắt đầu chơi -> cần có 1 biến để nhận diện, khi chưa 
      click vào nút New Game thì có giá trị false và click vào nút New Game thì có giá trị là true
    Nhận diện xem người đã đã bắt bắt đầu chơi hay chưa(khi fresh lại trang là chưa bắt đầu chơi), nếu chưa bắt đầu chơi thì cần 
      hiện thị ra câu thông báo đó là "Vui lòng nhấn New Game"
    Khi nhấn vào New Game thì cho hiện lên modal(popup) để hiển thị luật chơi -> cần có 1 biến để nhận diện khi nào thì popup này được 
      hiển thị
    Phải nhận diện được ai là người đang chơi activePlayer khi có giá trị 1 thì có nghĩa là người thứ nhất đang chơi, có giá trị 2 có
      nghĩa là người thứ 2 đnag chơi
    -> Các dữ liệu: score, currentScore, dice1, dice2, isPlaying, activePlayer
  Khi nhấn vào nút New Game:
    1. Show popup
    2. Reset lại Data
    3. Xây dựng popup
  Khi click vào nút Roll Dice để xoay xúc xắc
    1. Random dữ liệu 2 con xúc xắc
    2. Kiểm tra xem người dùng có quay trúng con số 1 hay không?
      Nếu xoay chúng số 1 -> đổi lượt chơi -> Reset điểm tạm thời
      Nếu xoay ok -> Cộng dồn vào điểm tạm thời cho người chơi đó  
  Hold -> lấy Điểm
    So sánh xem điểm cuối cùng có lơn hơn FinalScore hay không? nếu lớn hơn thì người đó chiến thắng
    Chưa đủ điểm -> Cộng dồn điểm chính thức -> Đổi lượt chơi

Tích hợp giao diện vào Vue
  Từ thư mục gốc ban đầu đó là HelloVueJs tạo thêm folder mới đó là DiceGame_Vue
  Gõ lệnh npm install để cài đặt các gói hỗ trợ
  npm run dev
  Xóa đi các component không cần thiết mà ban đầu mình đã copy từ HelloVueJs
  Khi tích hợp giao diện vào Vue thì các hình ảnh mình sẽ lưu vào trong thư mục assets và assets này được tính
    từ public
    output: {
      path: path.resolve(__dirname, './public'),
      publicPath: '/public/',
      filename: 'build.js'
    },
    {
      test: /\.(png|jpg|gif|svg)$/,
      loader: 'file-loader',
      options: {
        // name: '[name].[ext]?[hash]'
        name: function(file) {
          return 'assets/[name].[ext]?[hash]';
        }
      }
    }
    -> Định dạng url cho các file hình ảnh url('/public/assets/back.jpg');
    Các tấm hình này thì minhf sử dụng luôn nên ko cần để trong thư mục src/assets, các tấm hình ở trong src/assets
      thường sẽ là import hoặc là khai báo trực tiếp ở trong html. 
    Khi gõ lệnh npm run build thì các tài nguyên js và các tài nguyên nằm trong public/assets do đó trong phần CSS
      trong App.vue cần trỏ đến public/assets bởi vì đoạn CSS này khi hiển thị lên Vue thì sẽ được khai báo trong thẻ
      style của index

Xây dựng các Component cần thiết: 
  Tiến hành tách ra thành các component nhỏ hơn: Người chơi, các nút control, cục xúc xắc
  Khi tiến hành tách components thì cũng tiến hành tách luôn CSS
  Players Component: Trong trường hợp này thì chỉ có 2 player nên ko cần tách ra thành các player components, trong 
    trường hợp có 1 danh sách các players thì nên tách

Xây dựng Logic dữ liệu cơ bản
  Các thông tin cần lưu: 
    Điểm của người chơi: Có 2 người chơi nên có thể lưu vào 1 mảng có 2 phần tử tương ứng với điểm của từng người chơi
      -> Truyền điểm vào Players Component thông qua props
    Điểm tạm thời: Điểm tạm thời này có sự luân phiên qua lại với nhau, khi lượt chơi thuộc về người nào thì người đó
      có điểm tạm thời, lúc này điểm tạm thời của người kia bằng 0 -> Không cần lưu bằng mảng mà có thể lưu bằng 1 biến
      đơn
    activePlayer: Dùng để nhận diện ai là người chơi hiện tại, người nào đang chơi thì người đó được active
      0: Người thứ nhất là người chơi hiện tại
      1: Người thứ 2 là người chơi hiện tại
    v-bind:class Khi dàng buộc dữ liệu vào trong class thì truyền vào 1 Object, key là tên class, value là điều kiện để 
      xảy ra class đó
    isPlaying: Kiểm tra xem có đang chơi game hay không
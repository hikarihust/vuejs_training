<VirtualHost *:80>
  ServerAdmin proj_news.xyz
  DocumentRoot "C:/xampp/htdocs/vuejs"
  ServerName proj_news.xyz
  ErrorLog "logs/proj_news.xyz-error.log"
  CustomLog "logs/proj_news.xyz-access.log" common
</VirtualHost>

========================================== Cài đặt môi trường ==========================================

Cài đặt nodeJs. Khi cài đặt nodeJs thì sẽ có sẵn npm
Trước khi cài đặt thì kiểm tra xem nodeJs đã được cài đặt hay chưa bằng cách dùng câu lệnh node -v, npm -v
	trên PowerShell
Git -> Để Deploy mã nguồn lên server(sử dụng các hosting free)

========================================== Vuejs cơ bản ==========================================
Tìm hiểu về Vue Instance:
  Nghiên cứu cách tích hợp Vuejs vào trong 1 phần dự án đã tồn 
  Tích hợp Vuejs
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.18/vue.min.js"></script>
  Vue Instance là 1 thực thể Vue hay đối tượng Vue dùng để quản lý một thành phần trong trang web
  Khi tạo 1 Instance thì cần truyền vào 1 đối tượng để khai báo các thông tin liên quan như là: Đối tượng Instance
    đó quản lý thành phần nào
  Data and Methods:
    Data: Dữ liệu giành cho thành phần mà nó quản lý
  
Ràng buộc dữ liệu một chiều với Data Binding:
  Keywords: Template Syntax
  Đối với js khi sử dụng trong Vuejs sẽ có 1 số chú ý khi viết dấu {{}} đó là chỉ sử dụng được các biểu thức đơn giản
    như cộng trừ nhân chia, toán tử 3 ngôi thay thế cho biểu thức điều kiện, hay là sủ dụng các Methods của js cung
    cấp sẵn;
    {{ number + 1 }}
    {{ ok ? 'YES' : 'NO' }}
    {{ message.split('').reverse().join('') }}
  Không sử dụng được trong các trường hợp như là khai báo biến, hay sử dụng các câu lệnh điều kiện if-else

Sử dụng v on xử lí sự kiện người dùng: Cách sử dụng và cách khai báo Event trong Vuejs

Cách sử dụng Event Modifiers:
  stop và prevent
  Có thể viết bằng Javascript thông thường, tuy nhiên thì nếu sử dụng Event Modifiers thì sẽ giảm được 1 số đoạn code 
    thường lặp đi lặp lại trong quá trình sử lý
  Khi làm ứng dụng 1 trang Single Application thì Form cần phải được xử lý riêng, khi người dùng nhấn nút submit thì
    không cho trang chuyển hướng đến trang khác mà sẽ tạm dừng ở đó, sử lý dữ liệu trực tiếp bằng js sau đó sử dụng các
    công cụ khác để tương tác với server và gửi dữ liệu sang server.
  Để khi submit form mà nó không chuyển trang đi thì ở trong js có 1 khác niệm rất quen thuộc đó là preventdefault
  stopPropagation: Ngăn chặn sự kiện của phần tử con lan tỏa ra phần tử cha
Key Modifiers: Thường sử dụng với các ô input
  Chẳng hạn như trong form có input submit, thì trong trường hợp này khi mình nhập vào form rồi nhấn Enter thì nó sẽ chạy
  Thay cho việc dùng keycode để kiểm tra nhấn nút Enter thì có thể viết:
    <input v-on:keyup.enter="submit">
  Cũng kiểm tra tương tự thì có thể kiểm tra việc nhấn 
  enter, tab, delete (captures both “Delete” and “Backspace” keys), esc, space, up, down, left, right...
Tìm hiểu về Computed:
  Đối với Template của Vuejs {{}} thì sử dụng khá thuận lợi, tuy nhiên chỉ nên dùng trong các trường hợp mà biểu thức
    của mình là đơn giản, đối với các trường hợp mà biểu thức phức tạp thì không nên đặt ở phía Template mà nên sử dụng các
    thuộc tính hay method để thực hiện các logic
  computed là 1 thuộc tính trong object truyền vào đối tượng Vue. Computed có nhiều thuộc tính bên trong mà mỗi 1 thuộc
    tính là 1 function, các function này được tính toán dựa vào các dữ liệu có sẵn
    Ở đây thì nếu dùng method thì khi gọi đến ở Template thì cần phải có lời gọi hàm đi cùng nghĩa là cần có dấu ()
  Sự khác của method so với computed đó là khi sử dụng method thì phát sinh ra vấn đề đó là sô s lượng method sẽ được run 
    không mong muốn, có nghĩa là sẽ chạy bị thừa. Nếu mà khi thao tác với dữ liệu lớn thì sẽ làm giảm tốc độ chương trình.
    Do đó trong trường hợp này sẽ sử dụng computed
    <button v-on:click="a++"> A=A+1 </button>
    <button v-on:click="b++"> B=B+1 </button>
    <p>Number + A = {{ addA() }}</p>
    <p>Number + B = {{ addB() }}</p>
  Giải thích:
    Khi sử dụng method thì trong Template sẽ dùng lời gọi hàm, khi có bất kỳ 1 sự thay đổi nào thì Vuejs nó sẽ render lại
      Template do đó khi gặp lời gọi hàm nào thì nó sẽ luôn luôn chạy hàm đó.
    Đối với computed thì tuy khai báo giống như 1 hàm tuy nhiên thì nó sẽ được lưu vào đối tượng Vue, và hàm này chỉ được
      thực thi khi mà dữ liệu trong hàm đó có sự thay đổi
  => method thì sử dụng khi tính toán dữ liệu nó không dành riêng cho data, computed được dùng dựa trên dữ liệu của đối
    tượng Vue
Ràng buộc dữ liệu 2 chiều:
  <div id="app">
      <h1>FirstName = {{ firstName }}</h1>
      <input v-on:keyup="handleKeyUp" type="text" placeholder="Nhap firstName">
  </div>
  Dàng buộc dữ liệu 2 chiều được thể hiện ở chỗ dàng buộc biến trong data của mình vào trong ô input và đồng thời ô input
    nó sẽ dàng buộc ngược lại dữ liệu của mình khi người dùng nhập vào
  Vue cung cấp 1 chỉ thị để có thể làm việc này nhanh hơn đó là v-model

Ràng buộc Class bằng VueJs:
  Một phần thường xuyên xuất hiện trong các yêu cầu khi sử dụng Javascript thuần tương tác với cấu trúc Dom đó là việc thay
    đổi Class và thay đổi Style của 1 phần tử
  Class hay Style thì bản chất nó cũng là 1 Attribute, nó là thuộc tính của phần tử Html
  Đối với 1 phần tử thì có thể có nhiều Class, Trong VueJs thì dùng 1 đối tượng để quản lý các class

Ràng buộc Style cho phần tử:
  Đối với style thì có 1 số lưu ý riêng khi tương tác với 1 số phần tử đặc biệt như:
    <div style="background-image: url('https://cdn.pixabay.com/photo/2017/03/02/08/58/background-texture-2110724__340.jpg')">

Render Template dùng biểu thức điều kiện:
  Dùng để render ra các phần tử Html nào đó theo điều kiện nhất định. Điều kiện chính là biểu thức của Javascript nó có thể theo
    biến lưu trong data hoặc biến được tính toán trong computed
  Bên cạnh việc sử dụng v-if, v-else thì có thể dùng v-show
  Khi dùng v-show thì các phần tử Html đều tồn tại trong cấu trúc DOM nó chỉ ẩn đi bằng style display:none Còn đối với v-if và v-else 
    thì nó sẽ remove luôn đi phần tử Html
Render Template dùng vòng lặp trong VueJs:
  Đối với vòng lặp để quản lý tốt được vị trí và thứ tự của các phần tử thì nên cung cấp cho VueJs 1 key để để phân biệt các phần tử 
    với nhau để phục vụ các logic như sắp xếp các phần tử, sort, filter... thì dùng đến 1 thuôc tính đó là key

Lưu ý về Loop và Condition trong VueJS: Tìm hiểu độ ưu tiên của v-for so với v-if khi sử dụng chúng chung với nhau
  Xét về độ ưu tiên thì vòng v-for có độ ưu tiên cao hơn v-if
    <div class="user" v-for="user in arrUser" v-if="user.isActive">{{ user.email }}</div>
  Đối với trường hợp này nên tạo ra 1 computed được tính toán dựa trên thông số isActive để lọc ra những user nào có trạng thái là
    active

Lưu ý quan trọng về Array và Object trong VueJs: Vấn đề quan trọng và nó thường gây ra lỗi khi ta tương tác với VueJS thông qua object
  và array
  Đối với 1 số hàm có sãn của array như: push(), pop(), shift(), unshift(), splice(), sort(), reverse()
    -> Khi sử dụng hàm này để thêm, sửa, xóa các phần tử ở trong thì hệ thống phản ứng sẽ hoạt động và render lại. Nếu không thực hiện
    bằng cách sử dụng các phương thức này mà gán theo các cách thông thường thì các giá trị thay đổi không được render lại trên view
  Muốn thực hiện thay đổi theo cách thông thường như vậy thì dùng 1 hàm có sẵn của VueJs đó là $set()
    app;
      Vue {_uid: 0, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: Vue, …}
    app.arrNumber;  
      (6) [1, 2, 3, 4, 5, 6, __ob__: Observer]
    app.arrNumber.push(7);
      7
    app.arrNumber
      (7) [1, 2, 3, 4, 5, 6, 7, __ob__: Observer]
    app.arrNumber[7]
      undefined
    app.arrNumber[7]=2000;
      2000
    app.arrNumber[0]=2000;
      2000
    app.$set(app.arrNumber, 0, 3000);
      3000
  Trong trường hợp thay đổi thành 1 object mới thì ok bởi vì địa chỉ cũng thay đổi, thì lúc này hệ thống phản ứng sẽ giám sát địa chỉ đó
    app.objScore;
    {__ob__: Observer}math: 7.5__ob__: Observerdep: Dep {id: 4, subs: Array(1)}value: {__ob__: Observer}vmCount: 0__proto__: Objectget math: ƒ reactiveGetter()set math: ƒ reactiveSetter(newVal)__proto__: Object
    app.objScore.english=10;
    10
    app.objScore = {math: 7, english:8}
    {__ob__: Observer}
  Thêm 1 phần tử bằng cách dùng $set -> sẽ được hệ thống phản ứng giám sát sự thay đổi
    app.$set(app.objScore, 'physics', 8);
      8

                                =======================================================================
                                              Demo bài tập thực hành tổng hợp số 01

Phân tích data và Xử lí Price
Xử lý Change Color
  Xử lý sự kiện khi người dùng Click vào màu sắc nhất định
  Thường thì khi sử dụng vòng lặp for thì sẽ dùng đến key gắn vào cho các phần tử Html
Sử dụng v html trong Vue
  Render ra Html danh sách đặc tính của sản phẩm
  Render ra được mã nguồn Html trong 1 đoạn text

                                =======================================================================
Giới thiệu và cài đặt Vue CLI
  Cách cài đặt 1 cấu trúc thư mục cơ bản để xây dựng 1 dự án theo mô hình Single Page Application
  Dùng để xây dựng nhanh 1 cấu trúc thư mục để quản lý mã nguồn
  CLI: Command Line Interface
  Keywords: vuejs Template webpack -> https://github.com/vuejs-templates/webpack
  Để chạy các câu lệnh để có thể cài đặt thì cần phải đảm bảo đã cài đặt nodeJs và npm
    $ npm install -g vue-cli: -g là chữ viết tắt của global, cài đặt vue-cli ở trong tầm vực global, mình ó thể sử 
      dụng nó ở bất kỳ nơi nào trong máy tính để tạo ra 1 cấu truc thư mục mẫu
    $ vue init webpack my-project: my-project chính là tên của dự án
      $ vue init webpack-simple helloVueJs
      ? Project name (helloVueJs) hello
      ? Project name hello
      ? Project description (A Vue.js project)
      ? Project description A Vue.js project
      ? Author (vudinhquang <vudinhquangk53@gmail.com>)
      ? Author vudinhquang <vudinhquangk53@gmail.com>
      ? License (MIT)
      ? License MIT
      ? Use sass? (y/N) n
      ? Use sass? No
        vue-cli · Generated "helloVueJs".
        To get started:
          cd helloVueJs
          npm install
            Cài đặt các thư viện khác mà nó sử dụng trong VueJS. Coi trong package.json, nó khai báo 
              tất cả các thư viện phụ thuộc vào bên ngoài
            Sau khi chạy câu lệnh này xong thì trong thư mục của mình có thêm thư mục là node_modules trong đó
              chứa tất cả các thư viện mà chúng ta có sử dụng
          npm run dev
            Câu lệnh này sẽ sinh ra 1 server ảo: http://localhost:8081/
    $ cd my-project
    $ npm install
    $ npm run dev
Cấu trúc Project, tìm hiểu Webpack và Babel
  Tìm hiểu về 1 số thành phần được tạo ra sau khi cài đặt cấu trúc thư mục
    package.json: Là nơi khai báo các thư viện, module ở bên ngoài mà mình sử dụng trong project
  Có 2 môi trường:
    Development: Là môi trường dành cho lập trình viên
      "devDependencies": {
        "babel-core": "^6.26.0",
        "babel-loader": "^7.1.2",
        "babel-preset-env": "^1.6.0",
        "babel-preset-stage-3": "^6.24.1",
        "cross-env": "^5.0.5",
        "css-loader": "^0.28.7",
        "file-loader": "^1.1.4",
        "vue-loader": "^13.0.5",
        "vue-template-compiler": "^2.4.4",
        "webpack": "^3.6.0",
        "webpack-dev-server": "^2.9.1"
      }
      -> Dùng trong quá trình lập trình
        Babel là 1 trình biên dịch của Javascript
        ES6:
          let name = 'join';
          const age = 28;
          let str = `My name is ${name}`;
          class Person {
            constructor(name = '', age = 28) {
              this.name = name;
              this.age = age;
            }
          }
          var arr1 = [1, 2, 3];
          var arr2 = ['abc', 'def'];
          arr = [...arr1, ...arr2];
    Production: Public ra cho user sử dụng
      "dependencies": {
        "vue": "^2.5.11"
      }
      -> Dùng xuyên suốt trong quá trình user dùng trang web của mình
  Webpack: Công cụ giúp đóng gói code, đóng gói mã nguồn
    Khi đẩy code ở dạng môi trường Production thì sẽ build ra bằng câu lệnh: npm run build lúc này sẽ sinh ra 1 
      thư mục nữa chính là thư mục chứa file Javascript cuối cùng đã được đóng gói. Để đóng gói được thì cần phải có
      webpack
    Lệnh: $ npm run build

Cấu trúc Project và Cấu hình cơ bản Webpack: Cấu hình lại thông tin cơ bản để phục vụ quá trình lập trình
  https://webpack.js.org: Xem hướng dẫn cách config
  index.html là file được chạy đầu tiên, trong đó có 1 đối tượng <div id="app"></div>, đối tượng Vue để quản lý app đó
    là nằm trong main.js thuộc folder src
  import Vue from 'vue' thực hiện import thư viện vue từ bên ngoài vào, thư viện này được khai báo ở trong package.json
    "dependencies": {
      "vue": "^2.5.11"
    },
   App from './App.vue'
    Trong đây là nơi khai báo toàn bộ mã nguồn, có 3 thành phần chính: template, script(Javascript), style để viết Css
    script:
      export default {
        name: 'app',
        data () {
          return {
            msg: 'Welcome to Your Vue.js App'
          }
        }
      }
    -> main.js là nơi sẽ import
    Mỗi thành phần trong Web tương ứng với mỗi component -> Tương ứng với 1 file *.vue
  Extension: 
    Keywords: Vue -> Vetur, khi cài đặt xong thì sẽ xem được cú pháp của App.vue dễ nhìn hơn
  Webpack là công cụ để đóng gói, do đó khi build thì có thể cấu hình lại nó chẳng hạn như vị trí index.html, tên thư mục
    có để đổi từ dist sang tên khác, hay vị trí của file ảnh logo.png cũng vậy
    -> webpack.config.js Là nơi để cấu hình webpack, để khai báo các thông tin liên quan đến trang web
    entry: './src/main.js', main.js là file nó sẽ chạy lần đầu tiên
    output: {
      path: path.resolve(__dirname, './dist'),
      publicPath: '/dist/',
      filename: 'build.js'
    },
      -> Đóng gói sẽ xuất ra ở đâu
      publicPath: '/dist/' là đường dẫn sẽ đóng gói ra bên ngoài
  
  Sau khi config xong thì gõ lệnh: npm run build, chạy xong câu lệnh này thì sẽ sinh ra được thư mục mới(dist), có thể thay
    đổi tên tùy ý
  loader: 'file-loader', là công cụ dùng để quản lý hình ảnh và đóng gói hình ảnh
    "devDependencies": {
      "babel-core": "^6.26.0",
      "babel-loader": "^7.1.2",
      "babel-preset-env": "^1.6.0",
      "babel-preset-stage-3": "^6.24.1",
      "cross-env": "^5.0.5",
      "css-loader": "^0.28.7",
      "file-loader": "^1.1.4",
      "vue-loader": "^13.0.5",            -> Để thông báo vue.js là file hợp nệ
      "vue-template-compiler": "^2.4.4",
      "webpack": "^3.6.0",
      "webpack-dev-server": "^2.9.1"
    }
    https://webpack.js.org/loaders/file-loader/#root
    options:
      name: '[name].[ext]?[hash]'
        ->
        name: function(file) {
          return '/images/[contenthash].[ext]';
        }

Tìm hiểu Component và cách tạo trong Vue: Cách xây dựng 1 component mới kết nối các component lại với nhau để tạo ra một 
  trang web hoàn chỉnh
  Mỗi component chứa đựng 1 thành phần trong trang web, mỗi component được quản lý bởi 1 file *.vue, do đó thì khi mà mình
    muốn tạo ra bao nhiêu component thì tạo ra bấy nhiêu file *.vue
  Cách xây dựng component thì nó sẽ có cấu trúc giống như cấu trúc html
    App
      Header 
      ListProduct
        Product
        Product
        Product
        Product
      Footer
  Mỗi Component có cấu trúc 3 phần
    template: Để viết mã nguồn html
    script: export default ra 1 object, object này giống với đối tượng Vue
    style: Nếu như component có CSS riêng thì sẽ viết ở đây
  Khi muốn sử dụng 1 component ở trong 1 component khác thì ngoài việc phải import vào thì cần phải đăng ký 
    trong component mà nó sử dụng
      Keywords: Single File Components
        components: {
          OtherComponent
        }

Cài đặt mã nguồn và tổ chức Component lồng nhau
  Khi chia sẻ các source code giữa các máy tính với nhau thì sẽ không chia sẻ tập tin node_modules mà thư mục
    này chỉ được sinh ra trong nội bộ máy tính của mình mà thôi.
    npm install -> node_modules
    public/  -> Đóng gói khi đẩy code lên môi trường Product để cho người dùng sử dụng

Tìm hiểu Props Down trong Vue
  Keywords: props
  Cách để truyền dữ liệu giữa các component với nhau
  props Là những Data, những dữ liệu mà mình sẽ truyền từ component cha vào component con
    -> Sử dụng cú pháp giống với thuộc tính, thuộc tính này là thuộc tính mà mình tự đặt ra -> Ràng buộc thuộc
      tính -> Sử dụng chỉ thị v-bind để ràng buộc dữ liệu vào trong thuộc tính này
  Khi khai báo sử dụng props rồi thì sử dụng nó giống như 1 data thông thường
  Đối với props khi không quy định gì cả thì có nghĩa là có thể truyền vào hoặc không và khi đó cần phải định 
    nghĩa dữ liệu mặc định
  Giả sử không truyền props thì cũng ko
  Demo: App chứa các thông tin: title, listArray[]
        title truyền vào cho CompHeader và CompFooter, truyền listUser vào cho ListUser
          Trong ListUser Component nhận được mảng giá trị ListUser truyền từ App sẽ tiếp duyệt từng user và truyền
            vào User Component
    -> Toàn bộ dữ liệu được quản lý ở App Component

Tìm hiểu Event Up trong Vue:
  Tìm hiểu cách truyền 1 thông điệp từ component con ra component cha để gửi thông báo muốn thay đổi dữ liệu từ component 
    cha
  Keywords: Custom Event trong Vuejs
  Tìm cách tương tác với dữ liệu
  Demo: 
    App.vue:
      <template>
        <div id="app">
          <!-- <CompHeader></CompHeader>
          <CompHeader /> -->
          <!-- <comp-header v-bind:titleHeader="title"/> -->
          <div class="container">
            <button v-on:click="title = 'Học lập trình Vuejs'">Thay đổi title từ Component App.vue</button>
            <comp-header v-bind:title="title"/>
            <list-user v-bind:listUser="listUser"/>
            <comp-footer v-bind:title="title"/>
          </div>
          <!-- <comp-footer/> -->
        </div>
      </template>
    Tại App.vue thì khi nhấn vào buttom thì thực hiện thay đổi title -> Khi đó thì hệ thống phản ứng sẽ hoạt động
    -> Component Header và Component Footer đều nhận được sự thay đổi đó
    Phần thực hiện này nó liên quan đến Props Down. Props là dữ liệu của cha truyền vào nên nó truyền xuống tất cả các 
      component con bên trong có sử dụng -> tự động phản ứng lại, render lại giao diện bất kỳ khi nào component cha(quản
      lý title) thực hiện thay đổi title.
  Trong thực tế có thể có nhu cầu phức tạp hơn đó là việc click thay đổi title ở trong Header Component. Trong trường
    hợp này thì không được phép thay đổi props trực tiếp từ trong component con. Về nguyên tắc thì props được truyền 
    từ component cha nên chỉ component mới có thể thay đổi
  Đây là 1 phần rất quan trọng bởi vì khi làm các dự án lớn thì sẽ lồng rất nhiều component lại với nhau, để tương tác giữa
    các component đó thì phải biết cách Event Up và Props Down
  Props Down -> Dùng để truyền dữ liệu từ cha vào con -> Thằng con chỉ được dùng thôi chứ không được thay đổi trực tiếp
    Component nào nắm giữ data thì chỉ có component đó có thể thay đổi thôi. title đang do App.vue nắm giữ nên chỉ App.vue
      mới có thể thay đổi thôi
  Event Up -> Truyền thông điệp(sự kiện) để thông báo cho component cha biết là nó muốn thay đổi dữ liệu -> Nhiệm vụ 
    của component cha là nhận được thông điệp và tiến hành thay đổi data.
    Việc gửi thông báo đó nó là mình sẽ tạo ra 1 sự kiện
    -> Phần này liên quan đến Custom Event trong Vuejs

    click -> Là sự kiện có sẵn trong VueJs, để khai báo click thì sử dụng từ khóa v-on:click="changeTitle"
      -> Phân dã ra làm nhiều thành phần nhỏ:
        'click' -> Tên của sự kiện
        'changeTitle' -> Hàm xử lý khi sự kiện được kích hoạt, có nhiều dạng sự kiện khác nhau. Đối với sự kiện click thì
          nó sẽ được kích hoạt khi người dùng click
  Tự tạo ra 1 sự kiện mới và tự đặt tên cho sự kiện đó, và định nghĩa khi nào nó được kíck hoạt, ở đây nó được kích hoạt
    thông qua những đoạn code(các sự kiện có sãn trong Vuejs thì nó được kích hoạt thông qua sự tương tác của người dùng)
    -> Để kích hoạt được thì dùng từ khóa là $emit -> gọi ở trong component con
  Khi dùng các sự kiện mặc định như click... thì nó đã truyền sẵn cho mình 1 biến $event, tuy nhiên khi tự tạo ra 1 sự kiện
    mới thì dữ liệu đó sẽ truyền vào tham số thứ 2 của $emit(); và e này là 1 đối tượng mình tự tạo ra(các sự kiện như
    click thì là do Javascript tạo)
  Demo Xóa user: Tạo thêm nút nhấn cho các user có chức năng xóa user
    Khi click vào nút nhấn delete thì cần phải truyền thông điệp ra ngoài App để nó có thể xóa được 1 phần tử nhất định
    Trong trường hợp này thì cấp độ nâng cao hơn trường hợp thay đổi title tại vì user không phải được gọi trực tiếp từ App
      Mà User component lại được gọi từ ListUser component
    Xét về mô hình truyền event:
      App -> truyền arrUser vào cho ListUser, tại đây ListUser component sẽ chạy vòng for để render ra từng user -> truyền 
        vào User component.
      Như vậy thì tại User component truyền event thông báo ra cho ListUser, bởi vì ListUser không phải component nắm giữ
        arrUser mà do App component nắm giữ. Do đó ListUser này cũng không được quyền thay đổi arrUser -> Tiếp tục truyền 
        tiếp event thêm 1 lần nữa ra ngoài App component, công việc truyền này chỉ thực hiện khi nó nhận được thông báo từ
        User component -> Thực hiện xóa tại App component
      splice(): Dùng để xóa đi 1 phần tử trong mảng
        array.splice(index, howmany, item1, ....., itemX)
          index: Vị trí xóa từ phần tử nào
          howmany: Xóa bao nhiêu phần tử
        Trả về danh sách đã xóa 

Sử dụng Ref trong Vue(Reference)
  Reference là 1 biến dùng để tham chiếu đến các phần tử html mà mình muốn sử dụng nó cho 1 mục đích của Javascript
  <input type="file"> -> Rất khó để có thể thay đổi được giao diện của nó, nên thông thường ở trong Javascript thuần người
    ta thường tạo ra 1 bản sao của nó bằng 1 html(buttom) khác dễ code hơn, dễ viết css hơn, dễ làm cho giao diện hơn, khi người ta
    bắt sự kiện click để có thể chọn 1 file từ máy tính thì người ta sẽ bắt sự kiện click thông qua nút(buttom) nhấn đó, thực ra nút 
    input type="file" này thực sự đã ẩn bên cạnh rồi
  Để chọn được avatar thông qua nút mà mình đã tạo bằng html(buttom) thì lúc này sẽ sử dụng Reference
  handleClickInputFile() có chức năng gọi sự kiện click vào ô input, thay vì người dùng trực click vào nút này thì mình sẽ click nó
    bằng code, truy cập vào input type="file" thông qua biến toàn cục refs của ô input đó.
    Do đó lúc này khi click vào buttom thì mình có thể chọn được avatar mặc dù đã ẩn input type="file"

Tìm hiểu Slot và bài tập ứng dụng: Cách sử dụng slot trong VueJs thông qua các ứng dụng thực tế
  Đối với props thì nó chỉ truyền vào cho component con những giá trị với kiểu dữ liệu cơ bản như string, number, array, object
  Khi muốn truyền 1 cấu trúc html vào cho component con thì việc này Slot có thể làm được
  Slot được sử dụng trong trường hợp mình muốn kế thừa 1 phần nào đó của component
  Demo: Ứng dụng các slot trong thực tế dùng để kế thừa lại và tăng tính sử dụng lại của 1 component
    Xây dựng 1 component để hiện thực 1 tab, phía trên là tiêu đề của tab nhận string của component cha truyền vào và 1 
      icon -> tiêu đề này thì có thể dùng props để truyền dữ liệu từ component cha sang component con
      Trong component con thì nội dung được kế thừa từ component cha được đặt ở vị trí của cặp thẻ <slot></slot>
    Phần dưới là phần dành cho tab gồm có danh sách nhiều tab, phía dưới là nội dung của tab đó. Khi click vào tab nào thì nội
      dung của tab đó sẽ được hiển thị
    Icon: ionicons
      https://ionicons.com/usage
    Tùy vào trường hợp mà sẽ hiển thị lên nội dung của tab tương ứng -> do đó cần có 1 biến nào đó để nhận diện hiện tại nó
      đang show tab nào
    Xử lý sự kiện click, khi click vào tab nào thì sẽ hiển thị tab tương ứng
    Khi tab nào được active thì tab đó có thêm class là active -> dàng buộc dữ liệu vào class
  
Tìm hiểu về Life Cycle: Vòng đời của 1 đối tượng Vue kể từ khi nó được khởi tạo cho đến khi nó được remove khỏi cấu trúc DOM
  https://vuejs.org/v2/guide/instance.html#Lifecycle-Diagram
  VueJs đã tạo sẵn 1 số function như: beforeCreate(), created(), beforeMount(), mounted(), beforeUpdate(), updated(), 
    beforeDestroy(), destroyed()
  Các function này VueJs tạo sẵn cho ta chèn vào giữa quá trình hoạt động của nó để có thể sinh ra các mã code trong đó xen
    giữa vào quá trình hoạt động từ trên xuống dưới của 1 đối tượng Vue
  Thứ tự run của các hàm này:
    beforeCreate() -> created() -> beforeMount() -> mounted
  beforeCreate(): Được chạy khi đối tượng Vue được khởi tạo và bắt đầu khởi tạo ra được vòng đời, Trước khi hệ thống phản
    ứng hoạt động
    Do đó tại function này thì khi truy xuất vào các data của component thì sẽ trả về là undefined bởi vì ngay tại thời điểm
      đó đối tượng Vue chưa xây dựng hệ thống phản ứng mà kể từ hàm created() trở đi thì có thể truy xuất được vào tất cả các
      data của component
  created(): Khi đối tượng Vue đã xây dựng xong hệ thống phản ứng, lúc đó toàn bộ dữ liệu có thể truy xuất được rồi thì sẽ
    thực thi hàm created()
    Là nơi thường truyền các đoạn code như gọi API, Call Ajax để lấy dữ liệu từ server về
  Việc compile(biên dịch) template html ra cấu trúc DOM, cho đến hàm mounted() thì toàn bộ cấu trúc DOM mới hiển thị ra Html
    Do đó thì cho đến đi vào hàm mounted() thì mới có thể truy xuất được vào cấu trúc DOM
    Do đó thì chỉ trong hàm mounted() trở đi mình mới có thể dùng các thư viện liên quan đến jQuery, Javascript thông thường
      để truy xuất DOM để thực hiện hành động nào đó tương tác với cấu trúc DOM
  beforeDestroy() và destroyed() được chạy khi đối tượng Vue bị hủy bỏ
  beforeUpdate() và updated() được chạy khi có bất kỳ 1 sự thay đổi nào đó về dữ liệu. Hàm beforeUpdate() được chạy trước, rồi
    sau đó mới chạy updated()
    Được dùng để bắt việc có sự thay đổi dữ liệu, có thể ứng dụng viết sử lý cho việc sau khi thay đổi dữ liệu xong thì 
    sẽ làm gì tiếp...
  -> Hàm hay được sử dụng đó là created() và mounted()

========================================== Xây dựng Game đổ xúc xắc ==========================================

Phân tích kĩ thuật và dữ liệu
  <div class="spinner dice-3"> Dùng để thay đổi xúc xắc bằng cách thay đổi số, đối với vấn đề này thì có thể sử dụng việc dàng
    buộc class trong VueJs -> Ramdom ra 1 con số rồi truyền vào class trên dice-*
  Active: Khi đến lượt người nào chơi thì người đó sẽ được active(được thêm class là active), đến khi có 1 người nào chiến thắng
    thì class active sẽ được thay bằng class winner và tên người chơi cũng được sửa lại là Winner
  Các hành động: Có các hành động đó là new game, rolldice, hold
  Các dữ liệu cần lưu: Lưu thông tin điểm chính thức, điểm tạm thời. Điểm tạm thời là điểm được cộng dồn mỗi lần người dùng đó
    xoay xúc xắc. Khi người dùng nhấn vào nút lấy điểm(hold) thì lúc đó điểm tạm thời đó mới được cộng vào trong điểm chính thức.
    Khi xoay xúc xắc thì phải có các con số để đại diện cho nó.
    Ngoài ra thì cần phải bắt thêm 1 sự kiện nữa đó là khi nào thì người ta bắt đầu chơi -> cần có 1 biến để nhận diện, khi chưa 
      click vào nút New Game thì có giá trị false và click vào nút New Game thì có giá trị là true
    Nhận diện xem người đã đã bắt bắt đầu chơi hay chưa(khi fresh lại trang là chưa bắt đầu chơi), nếu chưa bắt đầu chơi thì cần 
      hiện thị ra câu thông báo đó là "Vui lòng nhấn New Game"
    Khi nhấn vào New Game thì cho hiện lên modal(popup) để hiển thị luật chơi -> cần có 1 biến để nhận diện khi nào thì popup này được 
      hiển thị
    Phải nhận diện được ai là người đang chơi activePlayer khi có giá trị 1 thì có nghĩa là người thứ nhất đang chơi, có giá trị 2 có
      nghĩa là người thứ 2 đnag chơi
    -> Các dữ liệu: score, currentScore, dice1, dice2, isPlaying, activePlayer
  Khi nhấn vào nút New Game:
    1. Show popup
    2. Reset lại Data
    3. Xây dựng popup
  Khi click vào nút Roll Dice để xoay xúc xắc
    1. Random dữ liệu 2 con xúc xắc
    2. Kiểm tra xem người dùng có quay trúng con số 1 hay không?
      Nếu xoay chúng số 1 -> đổi lượt chơi -> Reset điểm tạm thời
      Nếu xoay ok -> Cộng dồn vào điểm tạm thời cho người chơi đó  
  Hold -> lấy Điểm
    So sánh xem điểm cuối cùng có lơn hơn FinalScore hay không? nếu lớn hơn thì người đó chiến thắng
    Chưa đủ điểm -> Cộng dồn điểm chính thức -> Đổi lượt chơi

Tích hợp giao diện vào Vue
  Từ thư mục gốc ban đầu đó là HelloVueJs tạo thêm folder mới đó là DiceGame_Vue
  Gõ lệnh npm install để cài đặt các gói hỗ trợ
  npm run dev
  Xóa đi các component không cần thiết mà ban đầu mình đã copy từ HelloVueJs
  Khi tích hợp giao diện vào Vue thì các hình ảnh mình sẽ lưu vào trong thư mục assets và assets này được tính
    từ public
    output: {
      path: path.resolve(__dirname, './public'),
      publicPath: '/public/',
      filename: 'build.js'
    },
    {
      test: /\.(png|jpg|gif|svg)$/,
      loader: 'file-loader',
      options: {
        // name: '[name].[ext]?[hash]'
        name: function(file) {
          return 'assets/[name].[ext]?[hash]';
        }
      }
    }
    -> Định dạng url cho các file hình ảnh url('/public/assets/back.jpg');
    Các tấm hình này thì minhf sử dụng luôn nên ko cần để trong thư mục src/assets, các tấm hình ở trong src/assets
      thường sẽ là import hoặc là khai báo trực tiếp ở trong html. 
    Khi gõ lệnh npm run build thì các tài nguyên js và các tài nguyên nằm trong public/assets do đó trong phần CSS
      trong App.vue cần trỏ đến public/assets bởi vì đoạn CSS này khi hiển thị lên Vue thì sẽ được khai báo trong thẻ
      style của index

Xây dựng các Component cần thiết: 
  Tiến hành tách ra thành các component nhỏ hơn: Người chơi, các nút control, cục xúc xắc
  Khi tiến hành tách components thì cũng tiến hành tách luôn CSS
  Players Component: Trong trường hợp này thì chỉ có 2 player nên ko cần tách ra thành các player components, trong 
    trường hợp có 1 danh sách các players thì nên tách

Xây dựng Logic dữ liệu cơ bản
  Các thông tin cần lưu: 
    Điểm của người chơi: Có 2 người chơi nên có thể lưu vào 1 mảng có 2 phần tử tương ứng với điểm của từng người chơi
      -> Truyền điểm vào Players Component thông qua props
    Điểm tạm thời: Điểm tạm thời này có sự luân phiên qua lại với nhau, khi lượt chơi thuộc về người nào thì người đó
      có điểm tạm thời, lúc này điểm tạm thời của người kia bằng 0 -> Không cần lưu bằng mảng mà có thể lưu bằng 1 biến
      đơn
    activePlayer: Dùng để nhận diện ai là người chơi hiện tại, người nào đang chơi thì người đó được active
      0: Người thứ nhất là người chơi hiện tại
      1: Người thứ 2 là người chơi hiện tại
    v-bind:class Khi dàng buộc dữ liệu vào trong class thì truyền vào 1 Object, key là tên class, value là điều kiện để 
      xảy ra class đó
    isPlaying: Kiểm tra xem có đang chơi game hay không

Chức năng New Game:
  Button New Game thì được đặt trong Control Component, tuy nhiên thì về việc xử lý thì phải xử lý trong App Component
   -> Áp dụng việc truyền dữ liệu từ Component con ra Component cha
  Hiển thị Popup để show luật chơi
  Kết hợp CSS3 với VueJS để xây dựng hiệu ứng - Zoom in - Zoom out -> Sử dụng hiệu ứng transform là scale
    Khi ở trạng thái đầu sẽ Zoom to popup, khi bật popup lên thì sẽ Zoom nhỏ lại, dùng transition để tạo hiệu ứng thay 
      đổi dần dần
  open-popup: Khi nó có class này thì popup được hiển thị lên và chạy hiệu ứng, để kết hợp với VueJs thì chỉ cần dàng 
    buộc class vào là được
  isOpenPopup: Xác định là khi nào thì sẽ hiển thị popup
    Popup được hiển thị khi người dùng click vào nút New Game. Khi click vào nút New Game thì đầu tiên Control.vue được chạy
      sau đó nó sẽ gọi hàm handleNewGame trong App.vue, tại đây thực hiện thay đổi isOpenPopup = true
    Khi click vào nút Đã hiểu nằm trên Popup thì sẽ bắt đầu cuộc chơi, Khi click vào nút Đã hiểu thì có nghĩa là người chơi
      đã đọc luật chơi rồi -> ẩn popup đi và Reset lại các thông tin đồng thời các con xúc xắc cũng reset về con số 1
  Đối với class trong VueJs thì có thể truyền vào 1 chuỗi cũng được:
    <div class="spinner" v-bind:class="'dice-1'">

Xây dựng chức năng Roll Dice: Chức năng xoay xúc xắc
  TH1: Khi người dùng chưa nhấn vào nút New Game mà nhấn vào nút RollDice
  TH2: Khi người dùng đã nhấn vào nút New Game
  -> Kiểm tra giá trị của biến isPlaying nếu là false tức là người ta chưa bắt đầu chơi, nếu là true thì mới chơi
  Mỗi con xúc xắc có giá trị từ 1 -> 6 do đó dùng hàm Math.random() để random dữ liệu rồi gán vào cho mảng dices
  Sau mỗi lần quay xúc xắc mà người chơi quay đúng phải 1 hoặc 2 con xúc xắc có giá trị là 1 thì dừng người chơi của người đó và 
    chuyển lượt chơi qua người còn lại và đồng thời điểm tạm thời của người chơi đó cũng phải Reset về 0 không thì thì tiến hành 
    cộng dồn điểm vào điểm tạm thời của người chơi đó
  Khi hiển thị ra thông báo người dùng đã quay trúng vào số 1 thì các con sắc phải được đảo xoay và chuyển đổi người chơi rồi
    -> setTimeout()

Xây dựng chức năng Hold Score: Chức năng lấy điểm
  Xét về mặt luật chơi thì người dùng có thể lấy điểm bất kỳ lúc nào sau khi mà xoay xúc xắc xong
  Kiểm tra xem ai là chơi hiện tại để cộng điểm tạm thời vào điểm chơi chính thức cho người đó
  activePlayer có giá trị là 0 và 1
  scorePlayer là 1 mảng lưu điểm của 2 phần tử -> có thể dùng trực tiếp activePlayer làm chỉ số để lưu điểm tương ứng của player
    đang chơi, nếu thực hiện theo kiểu gán thông thường this.scoresPlayer[this.activePlayer] += this.currentScore; thì giao diện
    nó không phản ứng lại cho mình
  Lưu ý: Khi tuownng tác vơi Array và Object thì cần phải cẩn thận ko nên thay đổi trực tiếp 1 phần tử nào đó của Array mà thay 
    đổi lại luôn địa chỉ của mảng bằng cách tạo lại 1 array mới hoàn toàn và Coppy dữ liệu từ Array cũ
    Keywords: Caveats
    -> Clone lại dữ liệu(spread operator)
  Khi đã cộng dồn xong thì cần phải đổi lượt chơi

Kiểm tra thắng cuộc:
  Việc đầu tiên là phải thu thập dữ liệu từ người dùng nhập vào trong ô input là Final Score, ai đạt được điểm này thì người đó
    là người chiến thắng
  Dùng đến việc ràng buộc dữ liệu 2 chiều
    Có 2 loại dàng buộc:
      1. Ràng buộc dữ liệu(thường dùng trong các thuộc tính html) -> v-bind. Ở đây thì mình chỉ ràng buộc ở bước đầu tiên thôi, khi
        load lại trang hoặc là khi nó Render html ra thì giá trị trong data sẽ được gán vào trong value và sau đó nếu như mà có bất
        kỳ sự thay đổi nào liên quan đến dữ liệu thì nó không có gán trực tiếp vào biến trong data
        -> Chỉ có 1 chiều từ data -> input thôi chứ ko có chiều ngược lại 
      2. Ràng buộc dữ liệu 2 chiều -> v-model
        1 chiều từ data -> input
        1 chiều từ input -> data
      Nếu như nó không phải là data trực tiếp của Component Controls -> Nó không được phép thay đổi
  Các dữ liệu mà mình thu thập từ 1 ô input thì nó đều ở dạng chuỗi(string)
  Về nguyên tắc thì props không được phép thay đổi trực tiếp ở trong Component con
  Thay thế v-model bằng v-bind kết hợp với v-on mà trong đó sự kiện ở v-on sẽ thực hiện việc thay đổi giá trị của data
    -> Sự kiện lắng nghe sự thay đổi dữ liệu
      v-on:input="$emit('handleChangeFinalScore', $event)"
      v-on:change="$emit('handleChangeFinalScore', $event)"
  Sau khi tiến hành việc truyền sự kiện thành công từ Component Control sang Component App thì tiến hành lấy dữ liệu Final Score 
    để gán vào cho data. Ở đây thì tất cả các dữ liệu lấy ở trong ô input ra đều là dạng chuỗi do đó cần phải ép kiểu về dạng số
    trước khi gán cho Final Score.
    Khi tiến hành ép kiểu 1 dạng chuỗi sang số mà bản chất nó ko phải là số thì nó sẽ ra giá trị NaN
  Warning: Invalid prop: type check failed for prop "finalScore". Expected Number with value 0, got String with value ""
    Đối với kiểu dữ liệu của 1 props mình truyền vào mình có quyền khai báo thành nhiều kiểu dữ liệu, thay vì nó là 1 kiểu giá trị
      thì mình có quyền khai báo là 1 mảng
  Khi click vào nút New Game để tiến hành chơi thì không cho người chơi sửa Final Score nữa
  Cuối cùng là tiến hành kiểm tra người chơi nào là người thắng cuộc thông qua việc so sánh điểm chính thức của họ với điểm Final
    Score mà mình đã thiết lập, khi có 1 người chiến thắng thì sẽ thay thế class active của người đó bằng class là winner đồng thời
    thay tên người trời thành WINNER -> sử dụng computed
  computed -> function đó sẽ tự động được chạy bất kể khi nào mà dữ liệu bên trong đó có sự thay đổi
  Dựa vào giá trị activePlayer thì có thể biết được ai là người chiến thắng ở thời điểm đó
  Khi có người chiến thắng thì dừng cuộc chơi
  Khi cộng điểm vào cho mỗi người chơi thì cần phải xác định xem có ai là người thắng cuộc hay không? Nếu có thì dừng cuộc chơi và
    không chơi được nữa nếu ko thì chuyển người chơi
  Khi khi có người chiến thắng thì bỏ class="active" của người đó đi và thay vào là class="winner" cho người chơi đó

========================================== Xây dựng Project Todolist =========================================

Chức năng là quản lý các công việc cần phải làm hằng ngày theo mức độ ưu tiên
Có các chức năng cơ bản như thêm, sửa, xóa, tìm kiếm, sắp xếp, Clear từ khóa tìm kiếm

Tích hợp giao diện và phân chia Component
  Sử dụng thư mục gốc là HelloVueJs rồi chạy câu lệnh npm install để cài đặt các gói thư viện rồi chạy câu lệnh npm run
    dev để chạy server ảo. Trong trường hợp này thay vì dùng câu lệnh npm install thì mình có thể dùng câu lệnh yarn install.
    Để có thể dùng câu lệnh này thì trước tiên mình có thể cài đặt bằng câu lệnh npm install -g yarn
    Nếu dùng yarn install thì quá trình cài đặt sẽ được tiến hành nhan hơn bởi vì nó được cài đặt dựa trên cơ chế song song
    còn npm install thì dựa trên cơ chế tuần tự
  1. Tích hợp giao diện Bootstrap
    Khi thực hiện các dự án theo kiểu Single Application thì không nên import các thư viện thô kiểu như: 	<link rel="stylesheet" href="css/bootstrap.min.css">
      mà thay vào đó là sử dụng node_modules để sau này khi build sản phẩm cuối cùng nó sẽ đóng gói lại cho mình 1 mã nguồn tốt hơn
    Ngoài ra thì có sử dụng jQuery <script src="js/jquery.min.js"></script> nên đây cũng là 1 lý do mình không nên import trực tiếp 
      tại vì cơ chế render của Single Application khác với cơ chế thông thường. Khi mình mở 1 web tĩnh, khi tải lên thì toàn bộ html
      đã được tải lên xong rồi. Còn đối với Single Application thì mình khai báo theo hướng Component cho nên sẽ có lúc các Component
      chưa load kịp cho nên sẽ có trường hợp các jQuery mình sử dụng sẽ bị lỗi cho nên phần Bootstrap 4 mình sẽ import thông qua npm
      chứ không dùng các câu lệnh script trong html
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <script src="js/jquery.min.js"></script>
        <script src="js/popper.min.js"></script>
        <script src="js/bootstrap.min.js"></script>
    Keywords: Bootstrap vue
    Site: https://bootstrap-vue.js.org/
      -> Using module bundlers
      yarn add vue bootstrap-vue bootstrap: Để cài đặt các các phiên bản mới nhất của Vue.js, BootstrapVue and Bootstrap v4:
        bootstrap: Tải về các file css hỗ trợ về mặt giao diện
        bootstrap-vue: Tạo sẵn cho mình các Component theo kiểu Vue được sử dụng dựa trên Bootstrap != Với việc sử dụng thuần html
        vue: Đã được mình cài đặt rồi nhưng version là version 2.5.11
        Sau quá trình cài đặt này thì vue cũng được nâng cấp lên phiên bản mới nhất
      Để có thể cài đặt Bootstrap theo kiểu VueJs thì tiến hành đăng ký các thư viện ở cấp toàn cục trong main.js để có thể sử dụng trong
        mọi Component con
        Vue.use(BootstrapVue): Để mình đăng ký plugin BootstrapVue đối với VueJs được sử dụng ở cấp toàn cục để có thể sử dụng mọi nơi
          trong các Component
      Import vào các file Css:
        import 'bootstrap/dist/css/bootstrap.css'
        import 'bootstrap-vue/dist/bootstrap-vue.css'
    -> Biết các cài đặt Vue, biết cách sử dụng thư viện của bên thứ 3, cách import bootstrap vào ứng dụng Single Application theo kiểu là 
      VueJs mà không import theo kiểu thông thường bằng thẻ <script> mà sử dụng công cụ BootstrapVue. Khi dùng theo cách thông thông thường 
        thì khi mình đóng gói public sản phẩm ra thì các mã nguồn khai báo ở file html nó sẽ không được đóng gói lại -> chức năng của 
        webpack không phát huy tác dụng. 
      Cần đóng gói lại code để quản lý tốt về thứ tự khai báo, thứ tự chạy plugin đồng thời do được đóng gói code nên ứng dụng của mình sẽ
        chạy nhanh hơn.
      Đối với các ứng dụng Single Application thì khi khai báo jQuery trong các file html rất nguy hiểm, có lúc chạy bị sai vì nó liên quan 
        đến thứ tự load Component. Trong trường hợp script jquery được load trước, sau đó Component mới được sinh ra -> dẫn đến vấn đề động
        độ về time -> Hạn chế sử dụng jquery theo kiểu khai báo script
  2. Bootstrap Vue
    Tổ chức lại cấu trúc thư mục.
    Trong các dự án thực tế thì phải khai báo nhiều plugin do đó mình nên tách ra thành 1 thư mục khác cho dễ quản lý
      -> Tạo thêm thư mục mới là plugins
    Mô hình quản lý:
      main.js -> import file index.js, file index.js này nằm trong thư mục là plugins. File main chỉ cần quản lý 1 mình file  này
      index.js -> Gọi toàn bộ các plugin khác bên ngoài
      bootstrap.js -> import các thư viện liên quan đến bootstrap
    Tính năng Sort by, mình khai báo nó là dropdown, để dropdown này chạy được thì nó có sự cam thiệp của Javascript hay nói cách khác là mình
      phải import jQuery vào thì nó mới chạy
      Do đó những Component nào liên quan đến bootstrap mà có sử dụng, có ứng dụng tới Javascript thì cần sử dụng các Component được tạo sẵn
        của BootstrapVue
    Không phải là chỉ các phần tử liên quan đến Javascript thì mới được dùng các Component BootstrapVue mà các phần tử bình thường cũng có thể
      dùng được như row, col...
      Keywords: Grid system
  3. Component: Tách Component App ra thành nhiều Component nhỏ hơn
    Tất cả các Component mình tạo ra thì khi đặt tên nên đặt từ 2 từ trở lên.
      Ví dụ như Component cho 1 phần là title thì ko nên đặt đơn là Title vì nó dễ bị trùng với 1 từ khóa/thẻ khác trong html
        -> Nên đặt từ 2 từ trở lên
    TodoListTable.vue
      https://getbootstrap.com/docs/4.3/migration/#panels
      panel là 1 class của Bootstrap 3 sang Bootstrap 4 nó được chuyển đổi thành card
    <div class="container"> Thay thế bằng b-container
    <div class="row"> 
      Thay thế bằng b-row
    <div class="col-12 col-lg-6">
      Thay thế bằng <b-col cols="12" lg="6">
  
Hiển thị danh sách Task Items (Mock data, uuid)
  Mock data trong App Component rồi sử dụng props để truyền vào các Component bên trong đó là TodoListTable
  Khi hiển thị level thì ngoài vấn đề liên quan đến đoạn text thì còn có liên quan đến class mỗi level sẽ có 1 màu khác nhau
    Keywords: bootstrap 4 -> badge
  Hiện tại thì không cần quan tâm đến việc lưu dữ liệu -> Tạo mock data các data này thì mình tạo ra các file mới để cho dễ quản lý, ở đây thì
    các file mock này mình quản lý trong thư mục mocks
    Dùng các kiến thức của ES6 để tách file thông qua các từ khóa như import, export
  Sử dụng các thư viện hỗ trợ để sinh ra các id ngẫu nhiên
    Đây là 1 thư viện của nodeJs
    Keywords: uuid npm
    https://www.npmjs.com/package/uuid
    Cài đặt: npm i uuid
      const uuidv4 = require('uuid/v4');
      uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
  Tạo dữ liệu mock cho level
    { 
        name: 'Small',
        class: 'badge-info'
    }
    return this.mapLevel[this.task.level].class;
    Lúc này computed classLevel trả về class là 1 chuỗi, cũng không nhất thiết phải là 1 object

Chức năng Form Toggle
  Đối với Form nhập liệu thì mình sẽ cho ẩn đi, khi mà người dùng load lại trang lần đầu tiên hoặc là truy cập vào ứng 
    dụng lần đầu tiên thì Form được ẩn đi
  Trước khi thực hiện logic liên quan đến sự kiện thì mình tạo ra dữ liệu giúp nhận diện khi nào Form đó được ẩn và khi
    nào thì được hiện
  Form chỉ có 2 trạng thái hoặc là ẩn hoặc là hiển nên có thể sử dụng 1 biến Boolean có giá trị là true/false để quy định 
    việc này
  Bắt sự kiện click vào Add Task, sau khi click thì thay đổi data để ẩn hoặc hiện Form
  App
    CompForm
      FormAdd -> Click 
          -> Run onClickAddTask() 
          -> Kích hoạt Event handleAddTask 
          -> Kích hoạt tiếp toggleForm -> Tiến hành thay đổi giá trị isShowForm để ẩn hiện Form
  Khi Form đang được ẩn đi thì tiến nút hiện lên là Add Task, khi Form hiện lên thì thay thế nút này thành 1 nút khác chẳng 
    hạn như là Close Form
  Khi nhấn vào nút Cancel thì cũng hủy luôn Form -> Ẩn Form
    <button v-on:click="$emit('toggleForm')" type="button" class="btn btn-secondary">Cancel</button>

Xây dựng chức năng Search
  Thực hiện gõ tới đâu thì Search tới đó luôn
  Str Search: Ràng buộc dữ liệu 2 chiều từ việc thu thập dữ liệu từ người dùng
    Chuyển đổi dạng v-model thành mô hình v-bind kết hợp với v-on:input/change
    App -> CompControl -> ControlSearch
  Clear Search: Sau khi nhập vào ô input tìm kiếm rồi sau đó nhấn vào nút clear thì sẽ thay đổi giá trị strSearch thành giá trị rỗng
  Logic Search: Sau khi đã lấy được dữ liệu thu thập từ người dùng, dùng giá trị đó để thực hiện logic tính toán
    Đối Vuejs thì chỉ cần tập trung vào phần logic của method xử lý thôi, không cần quan tấm đến cấu trúc DOM nữa bởi vì hệ thống phản
      ứng sẽ tự động Render lại
    Tạo 1 computed thực hiện tính toán lại theo logic tìm kiếm của mình rồi sau đó truyền vào TodoListTable giá trị sau khi mình đã lọc
    Tiến hành tìm kiếm bằng cách tìm xem strSearch có tồn tại trong bất kỳ item nào hay không
    Keywords: how to Search string in another string Javascript
   Search Lowercase: Giải quyết vấn đề không tìm kiếm được các dạng chữ hoa, chữ thườngSearch Lowercase: Giải quyết vấn đề không tìm kiếm được các dạng chữ hoa, chữ thường
    Chuyển đổi hết về chữ thường 
    Keywords: Lowercase Javascript
    Khi thực hiện tìm kiếm mà không có kết quả trả về thì hiển thị lên 1 dòng chữ là List Empty, dùng colspan để merge các col thành 1
      <td colspan="4">List Empty</td> 
  Optimize Code:
    Sử dụng filter() thay cho foreach khi thực hiện tìm kiếm

Xây dựng chức năng Sort
  Có 4 cách sắp xếp: Name asc, Name desc, Level asc, Level desc
  Props Sort
    Dùng Css để hiển thị text bằng chữ in hoa
      .order {
          text-transform: uppercase
      }
  Event Up
    Sau khi nhận được sự kiện Click và lấy được tham số tương ứng thì tiếp tục sử dụng Event up để truyền sự kiện từ Component con ra 
      Component cha
  Method Sort: Thực hiện logic liên quan đến sắp xếp(Sắp xếp array)
    Keywords: sort Javascript
    https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
    Đối với phương thức sort() thì khi không truyền gì cả thì mặc định nó sẽ hiểu là so sánh chuỗi
      Khi sort đối với number
        function compareNumbers(a, b) {
          return a - b;
        }
      Khi sort đối với string -> Phải sử dụng if-else
        function compare(a, b) {
          if (a is less than b by some ordering criterion) {
            return -1;
          }
          if (a is greater than b by the ordering criterion) {
            return 1;
          }
          // a must be equal to b
          return 0;
        }
  Handle Sort: Áp dụng hàm sort của array để giải quyết bài toán
    Có 2 yếu tố cần sắp xếp đó là name và level, tương ứng với 2 yếu tố này thì cần có 2 hàm compare dành cho name và level
    compareName(): Việc sắp xếp theo tên thì việc return -1 hay 1 còn phụ thuộc vào asc hay desc
    listTaskSort(): Cần xác định là khi nào là sort theo level và khi nào là sort theo name
    Thực hiện kết nối Sort và Search: Thực hiện Search trước rồi mới Sort tức là thay vì Sort dựa trên mảng gốc thì mình sẽ sắp xếp
      dựa trên giá trị mà người dùng đã Search
  Optimize Code: Tối ưu hóa mã nguồn phần sort theo name và level

Xây dựng chức năng Delete: Xây dụng chức năng xóa 1 phần tử bất kỳ trong List Items
  Handle Event:
    Trước khi thực hiện delete thì cho hiển thị lên 1 câu thông báo để tránh xảy ra việc người dùng xóa nhầm -> Trước khi thực hiện 
      kích hoạt sự kiện ra bên ngoài ở TodoList thì gọi ra 1 câu thông báo
  Methods Delete: Tìm hiểu việc xóa 1 phần tử từ trong Array theo 1 điều kiện nào đó
    Keywords: remove element from array JavaScript, splice JavaScript
    splice - removes from a specific Array index -> Để thực hiện được thì cần biết được index của phần tử -> return về phần tử sau 
      khi xóa, làm thay đổi luôn mảng gốc
    filter - allows you to programatically remove elements from an Array ->return về mảng sau khi xóa, không làm thay đổi mảng gốc
  Handle Delete: Tiến hành delete dữ liệu thông qua hàm filter

Xây dựng chức năng Add New Task: Thêm mới 1 phần tử vào trong task
  Cần lấy được data mà người dùng nhập vào Form, Khi người dùng nhấn vào nút Submit thì lấy dữ liệu mà người dùng vừa nhập truyền ra
    bên ngoài và tiến hành thêm mới vào array
  Khi nhấn vào nút Submit xong thì ẩn Form đi, Reset lại dữ liệu

Xây dựng chức năng Edit
  Event Up:
    Khi nhấn vào nút Edit thì cần truyền được task ra bên ngoài để App có thể nhận diện được mình Edit task nào
    Có sự tương tác giữa 2 Component khác nhau, không chỉ đơn thuần là truyền ra App mà mình cũng cần phải truyền qua Form vì khi Người
      dùng Click vào Edit thì cần lấy được dữ liệu của task đó truyền lên Form để show ra Form cho người dùng -> Them data mới là taskSelected
    Form cần nhận diện được khi nào Add và khi nào là Edit
    taskSelected khác null thì có nghĩa là người dùng đang tiến hành Edit, bằng null thì là Add
  Form Edit:
    Sau khi lấy được thông tin của phần tử cần sửa -> tiến hành thực hiện logic liên quan đến Form
      - Click Edit => Object(taskSelected)
      - Open Form
      - Lấy data của taskSelected điền ra form để người dùng chỉnh sửa
    Khi thực hiện Close Form bằng cách nhấn vào nút Cancel/Close thì Reset taskSelected về null
    Khi người dùng chưa Click vào nút Edit thì taskSelected có giá trị null, khi người dùng click vào nút Edit thì taskSelected là 1 object
      có giá trị, lúc này sẽ truyền dữ liệu lên form -> Xử lý khi taskSelected có sự thay đổi
      Lifecycle Diagram
      beforeUpdate
      beforeUpdate và updated sẽ tự động được chạy bất kể khi nào dữ liệu có sự thay đổi
      Khi nhấn vào Add hoặc Edit thì isShowForm có sự thay đổi true <-> false -> beforeUpdate() được kích hoạt
  Watchers
    Hiện tại thì mình đang đặt việc xử lý ở trong beforeUpdate() nó sẽ chạy bất kể khi nào data có sự thay đổi. Trong trường hợp này là isShowForm
      taskSelected, taskname, level -> Có 4 dữ liệu có sự thay đổi. Mục đích của mình là chỉ muốn lắng nghe sự thay đổi của taskSelected thôi.
      beforeUpdate() là 1 method để theo dõi toàn cục
    -> Computed Properties and Watchers: Watchers có chức năng là lắng nghe sự thay đổi dữ liệu của riêng từng phần tử dữ liệu
      Tên function là trùng với tên phần tử dữ liệu cần theo dõi, tham số truyền vào là dữ liệu mới và dữ liệu cũ của phần tử dữ liệu đó
  Handle Edit:
    Vấn đề chỉnh sửa 1 phần tử trong Array dựa vào id của nó
      Cấu trúc dữ liệu là 1 array có nhiều phần tử, mỗi 1 phần tử là 1 object chứa các thông tin(id, name và level)
      Khi click vào Edit thì đã xác định được id của phần tử muốn sửa -> tìm được phần tử đó ở đâu, vị trí nào trong mảng
      Vấn đề liên quan đến hệ thống phản ứng khi thay đổi array hay object: Array Change Detection
        https://vuejs.org/v2/guide/list.html#Array-Change-Detection
      * Các hàm khi thực hiện thì địa chỉ không thay đôi nhưng có tích hợp sẵn hệ thống phản ứng: push(), pop(), shift(), unshift(), splice(), 
        sort(), reverse()
      * Đối với các hàm như filter(), concat() and slice() thì nó không tích hợp sẵn hệ thống phản ứng nên mà nó hoạt động theo nguyên tắc là luôn
        luôn trả về 1 mảng mới có địa chỉ hoàn toàn khác -> gán lại giá trị của mảng mới này vào data 
        this.listTask = this.listTask.filter(item => item.id !== taskDelete.id); lúc này thì địa chỉ thay đổi nên sẽ được render lại
      * Thêm mới hay xóa 1 phần tử 
        Vue.set(vm.items, indexOfItem, newValue)
        vm.items.splice(indexOfItem, 1, newValue)
          splice() ngoài việc xóa đi 1 phần tử ở 1 vị trí nào đó, thì còn thêm mới phần tử khác vào vị trí tương ứng
      -> Sử dụng splice() để giải quyết vấn đề chỉnh sửa 1 phần tử trong Array cho việc Edit task
    Keywords: findIndex JavaScript
    https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
      -> Tìm kiếm với điều kiện nào đó và return về index, nếu không tìm thấy thì trả về -1
    Bấm nút Update để Edit xong thì ẩn Form đi và xóa data trong Form đi

  Sử dụng LocalStorage
    LocalStorage:
      Hiện tại ứng dụng chưa kết nối với bất kỳ Server nào cả -> Lưu trữ cục bộ ở trong trình duyệt giống như COOKIE, các dữ liệu này sẽ lưu theo Domain
        -> Mỗi đường dẫn(Domain) sẽ có 1 dữ liệu riêng
      Keywords: LocalStorage JavaScript
      Console: LocalStorage -> có thể biết được các phương thức của LocalStorage
        clear, getItem, key, removeItem, setItem ...
      Tất cả dữ liệu lưu ở LocalStorage được lưu ở dạng String do đó nếu muốn lưu ở dạng Array hay Object thì dùng json stringify để format lại object/array
        theo dạng chuỗi -> Lưu vào trong Application. Khi lấy ra chỉ cần lấy ra và mã hóa lại bằng JSON.parse()
      -> Chọn thời điểm thích hợp để lưu dữ liệu vào trong LocalStorage và chọn thời điểm thích hợp để lấy dữ liệu để render ra view
    Ứng dụng: Lấy dữ liệu trong LocalStorage tại thời điểm chưa render rồi render ra -> Liên quan đến vòng đời của Component
      -> Thời điểm thích hợp để lấy dữ liệu về đó là created() tại vì lúc đó toàn bộ data, toàn bộ hệ thống phản ứng đã được hình thành rồi
      Dữ liệu trong LocalStorage là null khi người dùng chưa bao giờ sử dụng ứng dụng của mình hoặc là người dùng xóa dữ liệu của trình duyệt
      Lưu dữ liệu vào trong trình duyệt khi listTask có sự thay đổi dữ liệu -> watch

  Publishing ứng dụng
    npm run build: Publish sản phẩm
      Sinh ra thư mục public chứa toàn bộ mã nguồn đã được nén
      Khi public lên server cho người dùng sử dụng thì chỉ cần lấy file index và thư mục public
    Tạo New App có tên là todo-list-vuejs-training
    Download Heroku CLI rồi cài
    $ heroku login
      heroku: Press any key to open up the browser to login or q to exit:
      Opening browser to https://cli-auth.heroku.com/auth/browser/9ea478e1-0f0b-4dbe-8a38-c15d29167fdd
      heroku: Waiting for login...
      Logging in... done
      Logged in as vudinhquangk53@gmail.com
    ctrl + c: Quay trở lại gõ code
    $ git init
      Initialized empty Git repository in C:/xampp/htdocs/vuejs/basic/todo_list/TodoList_vue/deploy/.git/
    $ heroku git:remote -a todo-list-vuejs-training
      set git remote heroku to https://git.heroku.com/todo-list-vuejs-training.git
    $ git add .
      warning: LF will be replaced by CRLF in index.html.
      The file will have its original line endings in your working directory
      warning: LF will be replaced by CRLF in public/build.js.
      The file will have its original line endings in your working directory
    $ git commit -am "public"
      [master (root-commit) 79abd4f] public
      3 files changed, 29 insertions(+)
      create mode 100644 index.html
      create mode 100644 public/build.js
      create mode 100644 public/build.js.map
    $ git push heroku master
      remote:  !     Push failed
      remote: Verifying deploy...
      Khi đẩy code lên server thì nó không biết code của minh mã nguồn là gì. Server không hiểu file chạy đầu tiên là file nào vì file index
        mình đang để là index.html
      Để khắc phục vấn đề này thì mình sẽ tạo file index.php và include include.html vào đó
      Heroku sẽ tự động chạy file include.php
    $ git status
      On branch master
      Untracked files:
        (use "git add <file>..." to include in what will be committed)
              index.php
      nothing added to commit but untracked files present (use "git add" to track)
    $ git commit --amend
      [master bf33bbb] public
      Date: Wed Sep 25 00:19:42 2019 +0900
      4 files changed, 31 insertions(+)
      create mode 100644 index.html
      create mode 100644 index.php
      create mode 100644 public/build.js
      create mode 100644 public/build.js.map
    $ git push heroku master
      remote:        NOTICE: No runtime required in composer.lock; using PHP ^7.0.0
      remote:        - php (7.3.9)
      remote:        - apache (2.4.41)
      remote:        - nginx (1.16.0)
      remote: -----> Compressing...
      remote:        Done: 16.6M
      remote:        https://todo-list-vuejs-training.herokuapp.com/ deployed to Heroku

      Khi có file index.php thì nó sẽ nhận diện server là server php phiên bản 7.3.9
        -> Truy cập vào https://todo-list-vuejs-training.herokuapp.com/ để vào trang web

========================================== Sử dụng VueX với Project TodoList =========================================

Tìm hiểu VueX
  Why VueX
    Data:
      listTask: null,
      isShowForm: false,
      strSearch: '',
      orderBy: 'name',
      orderDir: 'asc',
      taskSelected: null
    Theo cấu trúc Component:
      App
        CompControl
          ControlSort
          ControlSearch -> CompControl -> App
            ABC
              XYZ
        CompForm
          FormAdd
            DEF
        ListTable
          TodoListItem
    Thực hiện các Component và tiến hành các chức năng, tất cả các phần xử lý thì mình đều thực hiện trong App, tuy nhiên thì các phần
      giao diện thì nó lại nằm ở trong các Component nhỏ hơn. Cho nên khi thực hiện 1 chức năng nào đó thì mình phải dùng đến Props Down
      và Event up
    Trong các bài toán phức tạp hơn muốn tương tác(Dùng chung data gì đó) giữa 2 Component là XYZ và DEF
      Dữ liệu lưu trong Comp App
      App -> CompControl -> ControlSearch -> ABC -> XYZ(Props Down)
      App -> CompForm -> FormAdd -> DEF
      
      Giả sử có 1 sự kiện thay đổi từ XYZ
        Event up:
          XYZ -> ABC -> ControlSearch -> CompControl -> App -> Thay đổi data(rồi kích hoạt hệ thống phản ứng) -> CompForm -> FormAdd -> DEF(nhận
            được data mới do XYZ thay đổi) 

      Trong các dự án lớn thì cấu trúc Comp lồng nhau nhiều và phức tạp thì như cầu truyền dữ liệu nhiều -> Nếu vẫn làm theo cách cũ thì độ
        phức tạp sẽ tăng lên -> Khiến cho ứng dụng khó bảo trì vì truyền nhiều, có bao nhiêu cấp thì phải truyền bấy nhiêu cấp
    => VueX là 1 thư viện, là mô hình quản lý dữ liệu giúp mình tách biệt dữ liệu ra ở một nơi khác. Toàn bộ dư liệu được lưu vào Store
      Store -> Nơi lưu toàn bộ dữ liệu dùng chung. Lúc này khi muốn sử dụng dữ liệu thì Props không phải truyền lần lượt nữa mà sẽ lấy trực tiếp 
        từ Store
        XYZ -> Lấy Data trực tiếp từ Store
        DEF -> Lấy Data trực tiếp từ Store
        Khi có bất kể sự thay đổi nào
          XYZ -> kích hoạt sự kiện thay đổi trong Store(hệ thống phản ứng sẽ hoạt động) -> Truyền ngược vào trong DEF
    Doc: https://vuex.vuejs.org/

  Counter: Qua đây tìm hiểu các kiến thức liên quan đến Vuex
    State:
      CompCounter và CounterTwo sẽ dùng chung về mặt dữ liệu -> Cài đặt VueX và tạo ra 1 Store để lưu trữ dữ liệu 
        dùng chung
      Install: Có 2 cách
        https://vuex.vuejs.org/installation.html
        Cách 1 dùng các thẻ script, thường dùng trong các dự án mà mình tích hợp riêng vào trong 1 phần của dự án lớn
          <script src="/path/to/vue.js"></script>
          <script src="/path/to/vuex.js"></script>
        Cách 2: Dùng npm để tích hợp vào toàn bộ dự án thông qua npm
          npm install vuex --save
      Khai báo plugin vào main.js
        import Vuex from 'vuex'
        Vue.use(Vuex)
      Để có thể tạo mới được 1 Store(nơi lưu trữ những dữ liệu dùng chung) thì cần tạo thêm 1 đối tượng mới
        const store = new Vuex.Store({
          state: {
            count: 0
          },
          mutations: {
            increment (state) {
              state.count++
            }
          }
        })

        Vue Instance
          Data -> dữ liệu của thực thể Vue đó
        Store
          State -> Giống như data của từng đối tượng Vue(từng Component)
            mapState()
      Để sử dụng được Store thì khi khởi tạo 1 đối tượng Vue truyền store vào đối tượng Vue đó, store là 1 thuộc tính 
        của đối tượng Vue
      Để có thể truy xuất được vào dữ liệu của store thì mình sẽ truy xuất qua con trỏ this truy cập vào thuộc tính là $store,
        -> dùng computed, tính toán dựa trên dữ liệu mà mình lưu trong store
        computed: {
            count () {
                return this.$store.state.count
            }
        }

  Computed, Getters
    Đối với com thì mình chỉ thường dùng đề lấy dữ liệu ra thôi, mình sẽ tìm hiểu đến việc sử dụng computed như một data thông thường, 
      nghĩa là ngoài việc render dữ liệu ra html thì mình còn có thể thay đổi dữ liệu trực tiếp
    Đối với 1 computed thì nếu như khai báo đầy đủ ra thì sẽ có 2 phương thức đó là get() và set(). Nếu như chỉ khai báo như thông thường 
      thì Vue hiểu đó là 1 phương thức get dữ liệu, mình chưa khai báo phương thức nào liên quan đến set dữ liệu mới
        count: {
            get () {
                return this.$store.state.count
            },
            set (newCount) {
                // Thay đổi state(count trong store)
                this.$store.state.count = newCount;
            }
        }
    Quy trình hoạt động của computed:
      get -> Lấy dữ liệu ra render vào template html
      set -> Thiết lập dữ liệu

      Khi user click vào button tăng computed count lên 1 đơn vị -> set sẽ được chạy
        -> Thay đổi lại count nằm trong store -> VueJs sẽ kích hoạt hệ thống phản ứng trong Store
        -> Đẩy dữ liệu về lại các Component có sử dụng 'count'
    Getters: Cũng giống như computed, mình sử dụng computed để lấy dữ liệu ra, ở trong store hỗ trợ mình Getters, nó giống như computed trong
      Component. Nó dùng để xử lý dữ liệu trước khi trả về cho các Component
      Giống với computed mỗi Getters là 1 function được dùng giống như là các biến, các function này nhận vào các state và return về các state
        tương ứng
    mapGetters(): Việc lấy các giá trị Getters trong store bằng cách thông qua con trỏ this: this.$store.state.count = newCount; thì hơi dài dòng,
      mapGetters() giúp cho việc lấy giá trị Getters đơn giản hơn.
        trong mapGetters() truyền vào các dữ liệu cần lấy

  Note State, Getters: Tiến hành làm rõ 1 số vấn đề 
    Có nhất thiết phải dùng setter của computed để thay đổi trực tiếp dữ liệu trong state của store?
      Điều này là không cần thiết bởi vì có thể thực hiện ở trong 1 hàm method
    Có nên thay đổi trực tiếp state trong từng component hay không. Tương tự như cách cũ là dùng props truyền dữ liệu vào các Component con, từ 
      đó kích hoạt sự kiện ra ngược bên ngoài, không được thay đổi trực tiếp props. Tương tự thì state cũng vậy, dù đối với store nó cho phép
      mình thay đổi trực tiếp trong từng component tuy nhiên thì không nên -> Có cơ chế khác để mình thay đổi dữ liệu trong state, việc thay đổi
      state trong các component thì trong các dự án số lượng component lớn thì sẽ rất khó quản lý -> chỉ thay đổi state trực tiếp ở trong Store
      mà thôi
    Theo quy tăc thì có phải luôn luôn lấy dữ liệu ra thông qua getter hay không
      Không nhất thiết phải dùng getter để lấy dữ liệu mà hoàn toàn có thể truy xuất theo cách thông thường được
        this.$store.state.count
      Việc dùng mapGetters() thì việc lấy dữ liệu sẽ nhanh hơn và quản lý tốt mã nguồn
    Tại sao cú pháp của mapGetters lại có thêm dấu "..." ở phía trước
      mapGetters() có tham số truyền vào là 1 array hoặc 1 object, trả về là 1 object
      Đối với computed thì thường nó là 1 object
        computed: {
          abc: function() {}
          def: function() {}
        }
      Đối với mapGetters() thì nó trả về 1 object, trong object đó có các method để lấy các value đã khai báo trong store
        getters: {
          count: state => {
            return state.count;
          },
          value: state => {
            return state.value;
          },
          countDouble: state => {
            return state.count * 2;
          }
        }
      "..." là cú pháp của ES6, không nhất thiết phải dùng dấu '...' mà có thể khai báo theo kiểu:
        computed: mapGetters([
          'count',
          'value',
          'countDouble'
        ]) mình chỉ khai báo trực tiếp như vậy khi bản thân Component đó không có computed riêng dành cho nó. Còn đây thì ngoài phần
        mapGetters() từ trong store, thì có những Component riêng của computed đó nên mình cần phải gộp chung bằng toán tử spread operator '...'
      Cách dùng mapGetters() cũng giống mới mapState()
        mapState() thì có thể bỏ luôn vào trong computed, nếu bỏ luôn vào trong computed thì không nhất thiết phải tạo ra getters()

  Mutations
    Không nên thay đổi dữ liệu trực tiếp của state trong từng Component đơn mà mình phải để store nó quản lý phần này. Ở các dự án lớn, số lượng 
      state có rất nhiều nên việc thay đổi nhiều nơi sẽ ảnh hưởng đến vấn đề debug cho nên ở các phần thao tác, thay đổi state sẽ đặt ở trong 
      phần mutations.
    Các Component muốn thay đổi state thì nó phải truyền thông điệp đến mutations này
    Mutations chứa các method để thay đổi giá trị trong state
    Để kích hoạt được các method trong mutations thì không được phép gọi trực tiếp mà phải gọi thông qua lệnh gọi là commit
    Đối với mutations thì phải tuân thủ theo quy tắc của hệ thống phản ứng
      Khởi tạo 1 giá trị mặc định ở trong state ở store
      Khi thêm 1 thuộc tính mới vào 1 object hoặc là thay đổi giá trị của 1 thuộc tính thì phải đảm bảo sao cho hệ thống phản ứng hoạt động tốt
        Có thể dùng Vue.set() để thêm 1 giá trị mới cho thuộc tính mới
        Có thể thay thế 1 obj bằng 1 obj khác có địa chỉ không bằng thằng cũ
          state.obj = { ...state.obj, newProp: 123 }
    Sử dụng hằng số để lưu Mutations Types, áp dung cho các dự án lớn. Lúc đó sẽ tách phần tên mutations ra 1 file riêng
    Vấn đề bất đồng bộ
      Nếu mà có các câu lệnh gọi api sang 1 server bên ngoài hoặc nếu sử dụng các method bất đồng bộ ở trong mutations thì sẽ gặp vấn đề
        mutations: {
          increment(state, number) {
            setTimeout(() => {
              console.log('Mutations increment', state);
              state.count += number;
            }, 1000);
          },
          decrement(state, number) {
            console.log('Mutations decrement', state);
            state.count -= number;
          }
        }
        Ở minh họa trên thì khi kích hoạt sự thay đổi thì nó sẽ không thay đổi ngay mà 1s sau nó mới thay đổi. Tương tự trong trường hợp tương
          tác với server thì server xử lý trong vòng bao lâu mã nguồn ko biết được vì đó là bất đồng bộ -> Khi tăng giá trị của count thì hệ thống
          phản ứng ko thay đổi -> khó khăn trong việc debug
      -> Toàn bộ code trong mutations là đồng bộ, (không được phép tương tác, gọi đến server ở trong mutations). Mutations chỉ có chức năng là 
        thay đổi khi nó nhận dữ liệu từ 1 nơi khác gọi đến chứ bản thân nó không được quyền tương tác với server.

  Actions
    Gần giống mutations, là các method để xử lý tuy nhiên:
      Actions không có sự thay đổi dữ liệu, nó chỉ tương tác và gọi sang mutations để mutations thay đổi
      Trong nội tại của Actions được quyền sử dụng các cơ chế liên quan đến bất đồng bộ, khi cần tương tác với server thì các thao tác đó đặt được 
        đặt ở Actions, sau khi tương tác xong lấy được dữ liệu rồi thì từ Actions truyền dữ liệu qua mutations để mutations thay đổi state
    Giống với Mutations thì khi khai báo Actions cũng là 1 function nhưng đối với Mutations thì nó tự động nhận vào state, ngoài ra là các tham
      số khác mình truyền vào. Đối với Actions thì truyền vào context, tham số này cũng tự động được dàng buộc
      Trong context có nhiều nội dung ở bên trong như commit, state, getters hay dispatch
    Thường thì 1 action sẽ gọi đến 1 mutations tương ứng nên tên action để giống với tên mutations
    Dùng dispatch để kích hoạt action
    Actions dùng để tương tác với server, xử lý dữ liệu -> Truyền dữ liệu đó vào trong mutations để nó thay đổi state
    Component có các thao tác các sự kiện để thay đổi dữ liệu -> dispatch 1 action -> commit 1 mutations -> Thay đổi state
    Lưu ý: Trong 1 action mình có thể kích hoạt 1 action khác thông qua lệnh context.dispatch() với tham số truyền vào là tên action cần kích 
      hoạt
    argument destructuring: Có thể phân dã context ra thành nhiều thông tin
    Tương tự như mutations thì mình có thể truyền vào các thông số khác, bản thân Actions cũng vậy, ngoài giá trị mặc định mà Vuex truyền vào
      là phần context thì mình có thể truyền thêm các tham số khác
    
  MapActions
    Kiến thức liên quan đến map
      state thì có mapState -> map vào computed
      getters thì có mapGetters -> map vào computed
      mutations có mapMutations -> map vào method
      actions có mapActions -> map vào method
    Khi dùng mapActions ở các Component thì có thể sử dụng được các action ở các Component giống như dùng các method thông thường
    Cú pháp của map là giống nhau, đều nhận vào array, object và trả về object. Thông thường thì tham số mình hay truyền vào là array,
      lúc này mình lấy trực tiếp tên định nghĩa trong main. Trong trường hợp thì tên mình khai báo trong main trùng với tên của các method
      khác ở trong Component thì lúc này mình có thể khai báo bằng 1 object để định nghĩa lại bằng tên khác

  Split File
    Tách nhỏ main.js phần store để quản lý các phần liên quan đến store

Hiển thị danh sách Items với VueX
  Install: yarn add vuex
  Ban đầu do tạo theo kiểu props nên mọi phần data mình đều quản lý ở trong App.vue, chuyển sang vueX thì component có sử dụng data nào thì
    chỉ lấy riêng data đó vào trong Component đó, không cần truyền listTask từ App vào TodoListTable bằng props nữa
  TodoListTable Component không cần nhận props từ bên ngoài truyền vào nữa mà sẽ lấy trực tiếp từ trong store thông qua mapState
  created(): Khởi tạo giá trị mặc định listTask -> không cần quản lý ở App nữa mà quản lý ở TodoListTable
    let tasks = localStorage.getItem('tasks') || '[]'; Nếu localStorage mà rỗng thì gán bằng '[]'
  watch: Bản chất là có thể lắng nghe từ computed chứ không nhất thiết là phải lắng nghe từ data
  Data được tách riêng, không quản lý chung vào trong App mà sẽ quản lý vào trong từng Component, Component nào dùng Data nào thì sẽ lấy trực
    tiếp vào trong Component đó -> không liên quan đến event truyền Component ra App, props truyền data từ App vào Component con như cách thông
    thường nữa

Form Toggle với VueX
  Show Form:
    Trong data của isShowForm có 1 biến đó là isShowForm, isShowForm được truyền vào CompForm thông qua props. Khi nó có giá trị true thì hiển 
      thị form còn false thì không hiển thị. Tại CompForm tiếp tục truyền isShowForm vào FormAdd bằng props
    -> Chuyển isShowForm lưu vào trong store
    FormAdd, CompForm: Không cần props nhận giá trị của isShowForm từ ngoài truyền vào mà thay thế bằng mapState để lấy giá trị của isShowForm 
      từ store
  Toggle Form:
    FormAdd: Có 1 sự kiện click
    Khi nhấn vào button Add Task thì nó chạy method là onClickAddTask() -> emit sự kiện handleToggleForm ra CompForm, tại đây tiếp tục emit 
      toggleForm ra App -> đưa toggleForm vào actions của store -> commit đến mutations để thay đổi state isShowForm để toggle Form
    App không cần các sự kiện và hàm để toggleForm
    CompForm không cần sự kiện và emit sự kiện để toggleForm ra bên ngoài
    Tại FormAdd không cần truyền sự kiện ra bên ngoài nữa mà kết nối trực tiếp đến store
    Cancel nằm trong CompForm, khi click vào nút Cancel thì cũng thực thiện toggleForm -> mapActions toggleForm vào trong CompForm

Xây dựng chức năng Search với VueX
  ControlSearch Component có sự dàng buộc dữ liệu 2 chiều với bên ngoài, tại App có nhiệm vụ thay đổi lại gá trị của strSearch
    -> Đưa strSearch vào bên trong state
  Xóa đi các Event liên quan đến handleSearch ở App và CompControl
  Xóa Props truyền giá trị strSearch từ ngoài vào trong
  Tại ControlSearch thay vì lấy giá trị của strSearch từ props thì import mapState, khai báo computed để lấy giá trị strSearch từ store ra 
    ngoài
    ControlSearch Component Gọi action handleSearch -> commit mutations -> thực hiện thay đổi state bằng giá trị mới nhập vào ô input
  Sau khi đưa được dữ liệu vào trong strSearch của store -> tiến hành thực hiện chức năng Search
  Trong TodoListTable là phần hiển thị list task -> cần phải tương tác được với strSearch, tại đây thì thay cho việc hiển thị trực  
    tiếp listTask ra ngoài thì cần phải có bước kiểm tra xem strSearch có giá trị hay không, nếu có giá trị thì tiến hành logic liên quan đến
    search và return về danh sách task sau khi đã tìm kiếm -> Sử dụng getters dựa vào strSearch và listTask trong state lọc ra dữ liệu tìm kiếm
    để hiển thị. Do đó tại TodoListTable Component thì không cần sử dụng đến mapState mà dùng mapGetters bởi vì listTask ko phải là lấy trực tiếp 
    từ state nữa mà sẽ lấy thông qua mapGetters đã tìm kiếm rồi
  ControlSearch Component: Khi nhấn vào Clear thì thực hiện tìm kiếm với key là chuỗi rỗng

Xây dựng chức năng Sort với VueX
  ControlSort và CompControl nhận prop là orderBy và orderDir từ bên ngoài App vào. Khi thay đổi thì 2 giá trị này được truyền ra ngoài App và App
    thực hiện lưu lại giá trị thay đổi.
  Chuyển đổi orderBy và orderDir vào trong state để ControlSort có thể lấy trực tiếp 2 giá trị này ra dùng mà ko cần phải nhận thông qua props
    và dùng event để chuyển đổi event ngược lại ra bên ngoài App
  App: Không cần truyền orderBy và orderDir vào Component con nên không cần v-bind orderBy và orderDir, không cần sự kiện kích hoạt handleSort
  CompControl: Không cần props orderBy và orderDir, đồng thời không cần truyền dữ liệu orderBy và orderDir vào ControlSort, không cần kích hoạt
    handleSort
  ControlSort: Không lấy orderBy và orderDir từ props nữa mà dùng mapState để triết xuất dữ liệu từ state ra
    Khi click chọn select box để thay đổi giá trị sort thì lấy dữ liệu của selected chuyển sang store
      -> tạo action handleSort -> mutations handleSort, tại đây thực hiện thay đổi orderBy và orderDir ở trong state
    Khi kích hoạt 1 mutations hay action thì data truyền ko thể truyền 2 tham số được mà thay bằng việc truyền 2 thông số mình có thể truyền 1 obj
  Thực hiện logic dựa vào giá trị của orderBy và orderDir. Giá trị hiển thị trong TodoListTable là được tính toán từ listTask thông qua giá trị
    của orderBy và orderDir. Việc này được thực hiện ở trong getters bởi vì getters cũng tương ứng với computed được tính toán dựa trên state có 
    sẵn. Getters này được tính toán thông qua 2 quá trình đó là Search và Sort

Xây dựng chức năng Delete với VueX
  Cách làm cũ: TodoListItem -> emit ra TodoListTable -> emit ra App. Tại đây có method để xử lý việc Delete, xử lý việc lọc ra các task 
    với điều kiện là nó khác với id mà mình truyền từ TodoListItem ra ngoài
    -> Tạo action mới trong action để xử lý vấn đề này -> commit sang mutations. Action có chức năng là thay đổi còn mutations có chức năng là
      thay đổi data.
    Không nhất thiết 1 action nó phải tương ứng với 1 mutations
  Trong action thì ngoài commit ra thì còn có state, getters và dispatch
    -> Không cần xử lý vấn đề handleDelete trong App, TodoListTable
  TodoListTable tiến hành gọi action

Xây dựng chức năng Add New Task với VueX
  Form được đặt trong CompForm
  Cách làm cũ: Khi click vào nút là Submit thì thực hiện handleAddNew() -> emit event ra ngoài App để thực hiện thêm tasks
  -> Xây dựng action mới handleAddNewTask -> commit đến mutations
  CompForm: Không cần emit ra bên ngoài mà sẽ gọi action

Xây dựng chức năng Edit với VueX
  Đối với Vuex thì các method xử lý thì thường đưa vào trong action, một action trong Vuex tương ứng với 1 method
  Một getter trong Vuex thì tương ứng với 1 computed
  Chức năng Edit được đặt ở TodoListItem
  Khi nhấn vào nút Edit thì không thực hiện theo kiểu emit từ TodoListItem ra bên ngoài nữa mà sẽ gọi dispatch trực tiếp action
    handleEdit, tại đây thực hiện thay đổi taskSelected thành giá trị mới là giá task mình muốn Edit, đồng thời thực hiện open
    Form bằng cách gán hía trị isShowForm thành true
    Lúc này TodoListItem nhận biết được task nào sẽ được sửa -> method actionhandleEdit() thực hiện kích hoạt action handleEdit()
      -> taskSelected trong state được update giá trị 
  Đối với 1 method trong Component thường được tách ra làm 2 phần là action và mutations. Action thường xử lý dữ liệu còn mutations
    thường thay đổi dữ liệu
  CompForm: Khi nhấn vào Update -> thực hiện handleEditTask() -> action handleEditTaskById() -> mutations handleEditTaskById() để 
    thực hiện thay đổi listTask dựa vào id của task được sửa và giá trị name, level được nhập/chọn
    Khi nhấn nút Cancel thì toggleForm() cũng được thực hiện -> lúc này nếu Form đang được open thì giá trị toggleForm cũng được 
      thay đổi về null và Form chuyển sang trạng thái close

LocalStorage
  watch dùng để lắng nghe sự thay đổi của listTask.
  Đối với Search và Sort thì nó sẽ tạo bản sao của listTask thông qua getters(cách cũ là tạo bản sao của listTask thông computed)
    -> Giá trị listTask ở trong state không thay đổi
  Do đó watch sự thay đổi của listTask, Mỗi khi add, edit hay xóa thì sẽ có sự thay đổi của listTask
  Đưa listTask vào computed của App.vue bằng mapState. Tại đây dùng watch để lắng nghe sự thay đổi của listTask
  -> App.vue chỉ thực hiện lắng nghe sự thay đổi của listTask, nếu listTask có sự thay đổi thì thực hiện thêm listTask vào localStorage 

Hệ thống kiến thức
  Một Store có cơ chế giống như 1 Vue Instance 
    data tương ứng với state
    computed tương ứng với getters
    method tương ứng với actions và mutations
      Không được sử dụng các method, các API bất đồng bộ trong mutations
      Actions dùng để tương tác với dữ liệu, tương tác với server, sau khi xử lý dữ liệu xong -> đẩy sang mutations. Mutations có chức năng
        truy cập vào State thay đổi state

========================================== Sử dụng VueX với Project Shopping Online ==========================================

Cấu trúc ứng dụng và VueX mở rộng
  Cài đặt mã nguồn và tách ra thành các Component nhỏ, tích hợp vuex
    Tiến hành cài đặt từ đầu mã nguồn vue thông qua webpack từ đầu
    Keywords: vuejs webpack simple
    https://github.com/vuejs-templates/webpack-simple
    vue init webpack-simple shopping_cart để cài đặt mã nguồn vue với tên Project là shopping_cart
    npm install
    Phần này mình sử dụng phiên bản bootstrap 3, không giống với bootstrap 4 nó có sẵn kiểu cài đặt npm. Đối với bootstrap 3 thì có thể cài đặt
      theo cách thông thường đó là sử dụng các mã nguồn js, css, images, fonts
    output: {
      path: path.resolve(__dirname, './dist'),
      publicPath: '/dist/',
      filename: 'build.js'
    },
      Như vậy thì tất cả các tập tin liên quan đến hình ảnh, css ở bên ngoài nếu như muốn cài đặt và bỏ vào trong index.html thì cần phải đưa
        vào trong thư mục dist
    Xóa đi phần định dạng mặc định của App.vue
    index.html chuyển đổi 1 số thông tin liên quan đến css, JavaScript... -> tất cả các file này được lưu trữ ở trong thư mục dist
    Copy mã nguồn html vào App Component
    Điều chỉnh lại các đường dẫn của các file hình ảnh -> các file ảnh được lưu trữ trong thư mục images nằm trong thư mục dist
    Tách ra thành các Component nhỏ hơn
    npm install vuex --save: Cài đặt vuex vào trong dự án
    modules: Tách nhỏ store thành các thành phần nhỏ hơn, thường áp dụng trong các dự án lớn 
    Tạo thư mục store và các file index, state, actions, mutations, getters và thư mục riêng dành cho module giỏ hàng thư
      mục này cũng có cấu trúc tương tự gồm index, state, actions, mutations, getters
    Import store vào trong main.js
  
  Modules: Tách store ra thành nhiều module
    Mỗi module thì nó cũng bao gồm có các thành phần giống như store: state, mutations, actions, getters. Mỗi module thì
      nó không nhất thiết phải bao gồm có tất cả các thành phần
    Để kết nối được các module vào trong store được thì thêm thuộc tính modules vào cho store
    Thêm 2 module cho project đó là cart và product 
    Để tránh xảy ra đụng độ giữa các module với nhau trong trường hợp giữa các module có tên của mutations, action hay 
      getters có tên giống nhau
      root -> có increment
        product -> có increment
        cart
      -> Giải pháp là truyền thêm 1 thuộc tính là namespaced: true ở trong từng module, như thì khi commit, dispatch, hay 
        dùng getters thì phải truyền thêm namespace của module:
        commit('product/increment')
    Lưu ý: Đối với việc lấy ra từ mapGetters, mapActions hay mapMutations thì truyền namespaced của module vào phía trước,
      tuy nhiên thì đối với việc lấy state thì khác, state được lấy thông qua state lồng nhau
        computed: {
            ...mapState({
                count: state => state.product.count
            })
        }

  Strict Mode: Kích hoạt chế độ nghiêm ngặt, không được phép thay đổi state ở bất kỳ đâu ngoại trừ ở trong Mutations
    strict: true -> kích hoạt là true cho đối tượng store.
    Nên dùng theo cú pháp: strict: process.env.NODE_ENV !== 'production'
      Khi đang ở chế độ developer thì strict sẽ được kích hoạt lên, còn khi đang ở chế độ production thì không cần kích
        hoạt strict lên
    Khi kích hoạt strict lên là true thì việc thay đổi state ở bên ngoài là không thể
      methods: {
          plus() {
              this.$store.state.product.count++; 
          }
      }

  Plugins:
    Plugins là 1 function, function này nhận vào 1 tham số là store
    subscribe là 1 method của store
    Cơ chế:
      Plugins được chạy khi store được khởi tạo
      subscribe() được gọi lại sau khi mutations làm thay đổi state -> giống như Watchers dùng để lắng nghe sự thay đổi 
        của state
        -> Có thể dùng nó để tương tác với LocalStorage. Khi nào dữ liệu thay đổi thì lưu vào trong LocalStorage


Xây dựng chức năng hiển thị sản phẩm
  State
    Gán dữ liệu tạm thời cho state productList của product là 1 danh sách sản phẩm
    ProductList Component: Kết nối với state và lấy danh sách product được lưu ở productList -> đưa vào computed của ProductList 
      Component

  Product Item
    Đối với các chỉ thị thì có 1 số cách viết tắt
      v-bind:key="item.id" -> :key="item.id"
      v-on:click="plus" -> @click="plus"
    template: Thẻ này có thể dùng để gom nhóm biểu thức điều kiện lại với nhau

  Display Price
    Để hiển thị Price thì mình tách ra thành 1 hàm hỗ trợ riêng vì có thể Custom được như đơn vị đặt ở phía trước, thay đổi đơn vị
      tiền...
    -> Tạo helper 

Xây dựng chức năng Add sản phẩm vào giỏ hàng
  State & Empty:
    Nếu giỏ hàng có sản phẩm thì render ra danh sách sản phẩm, nếu giỏ hàng rỗng thì hiển thị ra câu thông báo giỏ hàng rỗng
      -> Tạo constants/config để config các câu thông báo
    Biểu thức điều kiện không nên dùng chung với vòng for -> nên đặt biểu thức điều kiện nằm trong 1 thẻ template bao ngoài
  
  Check Quantity
    Khi nút nhấn là 1 thẻ <a> thì khi click vào mặc định nó sẽ nhảy sang 1 trang mới, href="#" -> dẫn đến hiện tượng nhảy lên trên 
      đầu trang.
      Để giải quyết vấn đề này thì có thể dùng e.preventDefault để ngăn chặn sự kiện mặc định của thẻ <a>. Tuy nhiên thì vuejs cung
        cấp sẵn Event Modifiers là stop hay prevent -> @click.prevent

  Notifications
    Thực hiện hệ thống thông báo khi kiểm tra dữ liệu mà người dùng nhập vào
    Config các câu thông báo ở constants/config.js
    Plugins: Notifications
      Keywords: vue Notifications
      https://www.npmjs.com/package/vue-notification
      Cài đặt: npm install --save vue-notification
      Khai báo vào trong main.js: 
        import Notifications from 'vue-notification'
        Vue.use(Notifications)
      App.js:
        <notifications group="noti" />
      .notifications: Có thể customize lại style

  Logic Add
    Khi người dùng nhập dữ liệu hợp nệ rồi và nhấn nút mua hàng -> đẩy dữ liệu vào store, mutations sẽ thực hiện thay đổi state của 
      giỏ hàng

  Duplicate: Giải quyết vấn đề khi người dùng mua liên tiếp nhiều sản phẩm giống nhau thì xảy ra vấn đề Duplicate dữ liệu
    -> Áp dụng bài toán kiểm tra xem 1 phần tử có tồn tại trong array hay không -> findIndex()
    javascript spread operator: Dùng để copy mảng hay đối tượng nhưng chỉ copy được 1 cấp
  
  Table Footer: 
    Tính tổng Quantity và tổng tiền
    -> Tính tổng 1 giá trị nào đó thông qua 1 Array có sẵn bằng cách sử dụng hàm reduce()
    Minh họa xử dụng hàm reduce():
      var listCart = [
          {
          product: {price: 22},
          quantity: 10
        },
          {
          product: {price: 5},
          quantity: 2
        },
          {
          product: {price: 10},
          quantity: 3
        }
      ];
      var initObjSum = {
        countItem: 0,
        totalPrice: 0
      };
      listCart.reduce(function(objSum, objCart) {
        let countItem = objSum.countItem + objCart.quantity;
        let totalPrice = objSum.totalPrice + objCart.product.price*objCart.quantity;
        return {countItem, totalPrice}
      }, initObjSum);
      -> Kết quả: {countItem: 15, totalPrice: 260}
    Thông tin hiển thị ở phần này được tính toán dựa trên dữ liệu có sẵn ở trong state -> xây dựng getters mới trong cart

Xây dựng chức năng Delete sản phẩm khỏi giỏ hàng
  -> Áp dụng bài toán xóa 1 phần tử trong mảng theo điều kiện nào đó

Xây dựng chức năng Update số lượng sản phẩm
  Loading: Khi nhập để thay đổi giá trị mới thì chưa thực hiện load lại trang, sau khi nhập gia trị mới rồi click chuột ra ngoài trang thì
    mới thực hiện load trang -> sử dụng sự kiện đó là onblur
    https://loading.io/
    Khi có sự kiện blur thì mới thực hiện hiển phần loading, set thời gian chạy loading
    -> Xác định biến toàn cùng để quản lý phần loading
      setTimeout(() => { 
          // Xóa loading
          this.set_loading(false);
      }, 1000)
      ---> Phải khai báo theo kiểu arrow function thì biến this mới được ràng buộc vào bên trong hàm và sử dụng được

  Logic Update: Đưa sự thay đổi giá trị update vào trong phần store để thay đổi trực tiếp cái state của giỏ hàng
    Khi check lỗi nhập giá trị sai xong thì hiển thị câu thông báo lỗi và đưa về giá trị gốc ở ô input
    Khi update lại số lượng muốn mua thì cần biết giá trị mới nhập vào là bao nhiêu, sản phẩm đó là sản phẩm nào

  LocalStorage
    Sai khi update xong thì thực hiện hiển thị câu thông báo
    Để lưu dữ liệu vào trong LocalStorage thì sử dụng Plugins, Plugins lắng nghe sự thay đổi, mỗi khi state thay đổi thì sẽ tiến hành lưu dữ 
      liệu vào trong LocalStorage
    Khi load lại trang thì trong state của cart sẽ lấy dữ liệu được lưu trong LocalStorage

========================================== Sử dụng VueX với Project Blog tin tức ==========================================

Tìm hiểu về Vue Router
  Init: 
    Sử dụng VueCLI để cài đặt thông qua câu lệnh: 
      vue init webpack-simple vue-router
      cd vue-router
      npm install
      npm run dev
      yarn add vue bootstrap-vue bootstrap(Tích hợp Bootstrap 4)

  Install Vue Router
    Tích hợp Bootstrap 4
    Install:
      https://router.vuejs.org/installation.html
      npm install vue-router, cài đặt bằng npm
      Import:
        import VueRouter from 'vue-router'
        Vue.use(VueRouter)
    Getting Started

  Router View
    Mô phỏng với 2 trang đó là trang Home và trang About Us
    Phần chung: Header(Menu, Slider)
    Phần riêng: Mỗi trang có Component
      Home -> '/'
      About Us -> '/about-us'
    const routes = [
      { path: '/', component: Home },
      { path: '/about-us', component: AboutUs },
    ]
      -> Được load vào <router-view></router-view>

  Router Link
    History Mode:
      Chế độ mode mặc định ban đầu là hash mode:
        http://localhost:8080/about-us#/ -> Giao diện vẫn giống với http://localhost:8080(Home)
        http://localhost:8080/#/about-us  -> Giao diện là trang AboutUs
      Chuyển đổi đường dẫn kiểu hash mode(/#/) sang kiểu history mode(/) 
        http://localhost:8080/#/about-us -> http://localhost:8080/about-us
    router-link:
      Tạo ra các đường link để người dùng có thể click vào để nhảy sang 1 trang bất kỳ đồng thời thực hiện đúng theo kiểu Single Page Application
        có nghĩa là khi click để chuyển đổi trang thì sẽ không load lại cả trang. Bản thân khi click vào 1 thẻ <a> thì thực hiện chuyển trang và
        load lại cả trang
      router-link là 1 Component, nó được render ra giống như 1 thẻ <a> đồng thời nó sẽ sử lý cho mình việc load Component chứ không load lại trang
        router-link mặc định render ra cho mình 1 thẻ <a> có class là: router-link-active và router-link-exact-active
          router-link-exact-active: Nếu như đường link khớp với path khi khai báo router { path: '/', component: Home } thì class này sẽ được sinh
            ra
        Khi dùng router-link thì mặc định sẽ dùng thẻ <a> nhưng có thể customize lại để dùng các thẻ khác bằng cách truyền props tag bằng 1 giá
          trị khác
        Khi kết hợp sử dụng router-link với Bootstrap-Vue thì cũng cần customize lại giá trị của activeClass và exactActiveClass. exactActiveClass
          là giá trị class khi được active
        Khi sử dụng router-link nhưng vẫn dùng giao diện của Bootstrap-Vue -> customize props tag bằng thẻ giống như BootstrapVue
        props:
          activeClass:undefined
          append:false
          event:"click"
          exact:false
          exactActiveClass:"active"
          replace:false
          tag:"b-nav-item"
          to:"/"

  Nested Routes: Mô tả các router lồng nhau, không nhất thiết là chỉ có 1 router view, có thể sinh ra thành nhiều router view ở bên trong
    Đối với việc config cho view router thì ngoài việc định nghĩa Component cho router đó thì còn có phần định nghĩa children để định nghĩa
      những router lồng bên trong
    Cấu trúc theo cách tư duy ban đầu, có thêm Login
      App
        Home -> '/':             Có Header Slider HomePage
        About Us -> '/about-us': Có Header Slider AboutUs
        Login -> '/login':       có Header Slider Login Form   
    Tổ chức lại theo cấu trúc Nested router:
      App(Dùng chung Menu):
        HomePage
          Menu Slider
                Router view(Home, AboutUs)
        Login(Không cần Slider)
          Menu Form
        -> HomePage có Slider dùng chung, Router View(Home, About Us)

  Dynamic Route:
    { path: '/user/:id', component: ListUser }
    Kết nối phần URL với phần dữ liệu data -> phải lấy được id mình đã truyền trên URL
    Hiện tại thấy rằng Component ListUser có 2 biến đó là: listUser và $route. 
    $route là biến toàn cục có chứa tất cả các thông tin liên quan đến URL
      Đường dẫn path
      params: Chứa thông số mà mình đã khai báo trong router view
    Áp dụng Lifecycle thì trong phương thức created() là nơi mình sẽ lấy dữ liệu về
    Url có 2 trường hợp đó là có truyền id và không truyền id. Trong trường hợp có truyền id thì có 2 trường hợp đó là id hợp lệ hoặc không hợp
      lệ
    Để RouterView nhận diện được Component ListUser thì cần khai báo url theo kiểu: { path: '/user/:id?', component: ListUser } tức là id có thể
      được truyền hoặc không
      Khi không truyền id lên url thì id:
      router-link: to được truyền khi có liên quan đến việc dàng buộc dữ liệu(bản chất nó là props)
        v-bind:to="`/user/${index + 1}`" 
    created(): Khi truy cập vào trang lần đầu tiên thì sẽ gán được giá trị currentId, còn trong quá trình mình thay đổi url bằng cách click chọn
      thì mình vẫn đang ở trong Component đó nên Lifecycle không được chạy lại -> created() không chạy lại. Lúc này thì phần data $route vẫn thay
      đổi nên mình có thể sử dụng watch để lắng nghe sự thay đổi của $route, khi $route thay đổi thì mình sẽ cập nhật lại giá trị currentId
      created() {
          this.currentId = this.$route.params.id;
      }
      watch: {
          $route(to, from) {
              this.currentId = to.params.id;
          }
      }
      to: link đến
      from: link ban đầu

  Not Found:
    Khi truy cập vào 1 đường link không hợp lệ, tức là đường dẫn truy cập vào không thỏa mãn bất kỳ 1 đường dẫn nào mình khai báo ở trong main.js
      nên không có Component nào được load để hiện thị cho RouterView 
    { path: '*', component: NotFound }
      Khi nhập bất kỳ 1 đường dẫn nào thì nó cũng thỏa mãn đường dẫn này, nếu như tất cả các đưởng dẫn mà ta khai báo ở phía trên không có cái
        nào thỏa mãn thì nó sẽ đi vào đường dẫn này
    Trong Component NOtFound có thể sử dụng RouterView hoặc Programmatic Navigation với phương thức push của $router để sang 1 trang khác 
      $router != $route
      $router cũng là 1 biến toàn cục, là 1 đối tượng đã được khai báo bên main.js
      $route là đối tượng dành riêng cho từng Component
    Đối với mỗi route thì ngoài đường dẫn path ra thì mình có thể khai báo thêm name
    v-bind:to="{ name: 'user', params: { id: index+1 }}" <=> v-bind:to="`/user/${index + 1}`"

  Navigation Guards: Liên quan đến việc giới hạn 1 vùng truy cập nào đó của user, hay có nghĩa là mình sẽ quyết định xem có cho phép người dùng truy cập
    vào url đó hay chưa dựa vào các vấn đề như login...
    Cấp global:
      Tất cả các URL đều chạy theo hàm này
      VueRouter cung cấp cho mình 1 hàm xử lý trước khi truy cập vào 1 url bất kỳ nào đó là beforeEach(to, from, next), hàm này được chạy trước 
        khi mình truy cập vào 1 url bất kỳ. Hàm này nhận vào 3 thông số là to, from và next, trong đó to và from là 1 object Route, còn next là 
        1 function, function này là công cụ để mình quyết định xem mình có cho phép truy cập vào url đó hay không nếu gọi đến hàm next() thì url
        sẽ redirect -> cho phép truy cập vào đường link của to
    Per-Route Guard: Dành cho từng route, có thể giới hạn 1 số url cần chạy -> beforeEnter

  Transition:
    Là công cụ giúp ta làm giao diện đẹp hơn, nó kết hợp với CSS để xây dựng hiệu ứng chuyển đổi giữa 2 Router với nhau
    Là kiến thức nằm trong Vuejs
    Transition cung cấp cho mình 6 class để xay dựng hiệu ứng được phân làm 2 nhóm: enter, leave
      enter: Khi 1 Component được gắn vào trong cấu trúc DOM
      leave: Khi 1 Component được remove khỏi cấu trúc DOM
    6 Class: 
      v-enter: Starting state for enter. Added before element is inserted, removed one frame after element is inserted.
      v-enter-active: Active state for enter. Applied during the entire entering phase. Added before element is inserted, removed 
        when transition/animation finishes. This class can be used to define the duration, delay and easing curve for the entering transition.
      v-enter-to: Only available in versions 2.1.8+. Ending state for enter. Added one frame after element is inserted (at the same time 
        v-enter is removed), removed when transition/animation finishes.
      v-leave: Starting state for leave. Added immediately when a leaving transition is triggered, removed after one frame.
      v-leave-active: Active state for leave. Applied during the entire leaving phase. Added immediately when leave transition is triggered, 
        removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the 
        leaving transition.
      v-leave-to: Only available in versions 2.1.8+. Ending state for leave. Added one frame after a leaving transition is triggered (at 
        the same time v-leave is removed), removed when the transition/animation finishes.
      v-enter-active và v-leave-active nó được sinh ra trong suốt quá trình và nó thường dùng để khai báo transition/animation
      v-enter/v-leave và v-enter-to/v-leave-to dùng để chuyển đổi trạng thái
    Transition Modes: Đối với Transition thì có 1 vấn đề đó là vấn đề enter và leave cùng diễn ra đồng thời -> để khắc phục vấn đề này thì
      có 2 chế độ mode đó là: in-out và out-in:
        in-out: New element transitions in first, then when complete, the current element transitions out.
        out-in: Current element transitions out first, then when complete, the new element transitions in. Được sử dụng nhiều, khi remove Kết
          thúc thì sẽ bắt đầu insert
    Name: Each of these classes will be prefixed with the name of the transition. Here the v- prefix is the default when you use 
      a <transition> element with no name. If you use <transition name="my-transition"> for example, then the v-enter class would instead 
      be my-transition-enter.

  Split File
    Cũng giống như store, mình sẽ tách 1 file riêng để quản lý router để khai báo tất cả các thông tin liên quan đến view router

Xây dựng cấu trúc ứng dụng
  Init Project: 
    Xây dụng 1 project dựa trên mã nguồn của html là 1 template có sắn
    Keywords: download template html bootstrap
    url: https://startbootstrap.com/themes/clean-blog/
    Lệnh cài đặt project:
      vue init webpack-simple project_blog_vue
      cd project_blog_vue
      npm install
      npm run dev
    Áp dụng cả các kiến thức liên quan đến VueRouter và vueX để sinh ra 1 số dữ liệu cơ bản dành cho 1 bài viết 1 blog tin tức
    Cài đặt Vue Router vào project
      npm install vue-router
    Cài VueX vào project
  
  Component: Tách component
    Trang có 4 pages: about, contact, index, post -> Coi mỗi 1 page là 1 thư mục lớn và lưu trong 1 thư mục riêng là pages
    Thư mục components để chứa các components dùng chung như Header, Footer...
    Coppy nội dung link trên thẻ head và nội dung trong script, đây chủ yếu là những phần khai báo sử dụng Css và JavaScript
    Tách ra thành các Component(Component dùng chung và riêng)
      Dùng chung có: Navigation, Page Header, Footer

Xây dựng Page Blog và cấu hình router
  Config Router:
    slot dùng để truyền thêm 1 dữ liệu mới

  Page Header:
    Khai báo 1 số props thay đổi như tấm ảnh hình nền, tiêu đề

  Faker:
    Keywords: npm faker
    Mục đích là để tạo ra dữ liệu mẫu
    Lệnh cài đặt: npm i faker

  Blog List: Render dữ liệu listBlogs ra giao diện
    Tiến hành render listBlogs ra giao diện
    Kết hợp sử dụng vuex
    Keywords: date format javascript

Xây dựng Menu và Custom Link

Xây dựng Page Login và giới hạn vùng truy cập
  Page Login:
    Phần html mình kế thừa lại từ contact
    Form login: Email và Password

  Config Router:
    Sau khi người dùng đã login thành công thì mình sẽ ẩn Form login đi và thay thế vào đó là hiển thị lời chào và kèm theo 1
      nút nhấn, nút nhấn này có chức năng là logout
    Giới hạn vùng truy cập. Khi người dùng truy cập vào 1 bài viết bất kỳ nào đó thì bắt buộc người dùng phải đăng nhập
    Per-Route Guard: beforeEnter
    Khi đăng nhập thành công thì tự động đẩy sang trang chủ
      Programmatic Navigation: this.$router.push({ path: '/' })

  Not Found: Xử lý trường hợp khi người dùng nhập vào 1 đường link ảo không tồn tại

==================================== Sử dụng API kết nối với Server Back End  ====================================

Xây dựng cấu trúc dự án
  Init Project
    vue init webpack-simple api_project
    cd api_project
    npm install
    npm run dev

    Store
    Vue Router
    Component
    
    Có header:
      Trang chủ
      Profile
      Thay đổi Password
      User
      Đăng ảnh
      Bài viết chi tiết

    Không có header:
      Trang đăng nhập
      Trang đăng ký

    Không có footer:
      Trang chủ
      Trang bài viết chi tiết

  Components: Tiến hành tách thành các component nhỏ từ mã nguồn html
    npm install vue-router
    npm install vuex --save
    Đối với Nested Routes thì mình chỉ tổ chức theo cấu trúc lồng nhau trong trường hợp mà chúng ta có sự kế thừa giao diện
      do đó thì mình sẽ tách hẳn luôn user-page và user-profile
    Một số vấn đề
      1.Cách import bootstrap đúng phiên bản(có thêm @4.0.0 ở phía sau)
        npm install vue bootstrap-vue bootstrap@4.0.0
      2.Vị trí đặt file style.css
        Sau khi di chuyển bootstrap vào trong có nghĩa là import trong main.js bằng cách import './plugins' thì lúc này sẽ
          không khai báo style.css ở trên index.html nữa mà sẽ đưa vào trong import trong main.js giống như import bootstrap
          để đảm bảo vấn đề style.css phải được load sau bootstrap
      3.Điều chỉnh lại toàn bộ background url trong style.css
        background-image: url('/dist/images/menu-bg.jpg');
    Import jQuery
      Keywords: jQuery npm
      Chỉ dùng jQuery ở AppHeader nên chỉ cần import vào AppHeader
    mounted(): Đảm bảo mã nguồn html đã load thành công, từ đó có thể dùng được mã nguồn jQuery để truy xuất các phần tử

Tìm hiểu Asynchronous trong Javascript và API
  Asynchronous: Tìm hiểu về bất đồng bộ và cách xử lý bất đồng bộ ở trong JavaScript
    synchronous: Đồng bộ
    asynchronous: Bất đồng bộ
    Javascript thực thi đúng với thứ tự mình khai báo trong code thì đó là chạy đồng bộ
    Javascript hỗ trợ sẵn cho mình 1 số hàm liên quan đến bất đồng bộ như: setTimeout()
    promise: 
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
      Đối với Promise được truyền vào 2 tham số: resolve và reject
    Một Promise có 1 trong 3 trạng thái:
      pending: Trạng thái chờ. Chưa thành công cũng không có lỗi gì cả, đây là trạng thái chờ Server xử lý
      fulfilled: Hoạt động đã thành công
      rejected: Trong quá trình xử lý xảy ra lỗi(có thể do server hoặc cú pháp...)
    then() và catch() là 2 hàm để lắng nghe khi nào thì Promise chạy xong
    then(): Chạy được khi Promise thành công
    catch(): Chạy được khi trạng thái của Promise là lỗi
    Giả sử như là có nhiều công việc liên quan đến nhau: login, getPostByUserId
      Sau khi đăng nhập thành công server trả về userId của user đó, sau khi có userId của user đó thì tiến hành thực hiện getPostByUserId(Lấy
        các bài viết của user đó)

  Async - Await:
    Thay vì dùng then và catch để xử lý bất đồng bộ thì mình dùng Async - Await trong javascript
    Keywords: Async function javascript
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function
    Dùng 2 từ khóa đó là async để khai báo hàm bất đồng bộ, await thay cho then và catch, dùng để chờ. Khi dùng await thì bắt buộc 
      bên ngoài phải là async
    Error regeneratorRuntime is not defined: Lỗi này đòi hỏi phải cài đặt babel-polyfill là 1 gói hỗ trợ cả babel-polyfill
      https://babeljs.io/docs/en/babel-polyfill
      Install: npm install --save @babel/polyfill
    package.json:
      "dependencies": {
        "@babel/polyfill": "^7.6.0",
        "bootstrap": "^4.0.0",
        "bootstrap-vue": "^2.0.4",
        "jquery": "^3.4.1",
        "vue": "^2.6.10",
        "vue-router": "^3.1.3",
        "vuex": "^3.1.1"
      },
    Cấu hình cho webpack
      webpack.config.js:
        module.exports = {
          entry: ['@babel/polyfill', './src/main.js'],
          output: {
            path: path.resolve(__dirname, './dist'),
            publicPath: '/dist/',
            filename: 'build.js'
          },

  API - Postman - Fetch API
    API: Application Programming Interface, là công cụ hỗ trợ cho 2 máy tương tác với nhau
    API chẳng qua nó là 1 đường dẫn, từ đường dẫn đó có thể gửi yêu cầu lên server để yêu cầu tài nguyên nào dó bên phía server
    Import Collection vào trong Postman
    Cách cài đặt biến môi trường trong Postman:
      Environment Name: vuejs
      VARIABLE: base_url
      INITIAL VALUE: http://api-meme-zendvn-01.herokuapp.com/api
      CURRENT VALUE: http://api-meme-zendvn-01.herokuapp.com/api
    {{base_url}}/post/getListPagination.php?pagesize=3&currPage=1
      {
        "status": 200,
        "message": "Thanh cong",
        "posts": [
            {
                "USERID": "3",
                "profilepicture": "http://api-meme-zendvn-01.herokuapp.com/public/user/3/32294391_163827007620829_994025092092526592_n.jpg",
                "fullname": "Huỳnh Thị Minh Trúc",
                "PID": "55",
                "url_image": "https://i.memeful.com/media/post/WdNWP7w_700wa_0.gif",
                "post_content": "Demo đăng bài viết 03 :2 ",
                "time_added": "2019-08-12 13:05:20",
                "status": "1",
                "count": null
            },
            {
                "USERID": "2",
                "profilepicture": "",
                "fullname": "Trần Công Lực",
                "PID": "53",
                "url_image": "https://i.memeful.com/media/post/BRkm0vw_700wa_0.gif",
                "post_content": "Demo",
                "time_added": "2019-08-12 10:38:42",
                "status": "1",
                "count": "1"
            }
        ]
      }
    Khi gọi API thì có thể cấu hình lại Headers, Body
    Fetch API javascript
      Để tương tác được với API thì dùng javascript
      Keywords: Fetch API JavaScript
      https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
      https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch
      https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
      Tham số truyền vào fetch() là 1 yêu cầu mà ở đây thì mình truyền vào URL, giá trị trả về là 1 promise
      Lấy dữ liệu trả về khi dùng API: response.json()

  Chức năng hiển thị danh sách bài viết 
    Axios - Call API
      Trong thực tế người ta ít khi dùng hàm mặc định fetch() của javascript để gọi API mà sẽ dùng thư viện khá phổ biến trong các dự án thực tế
        đó là axios. Axios có chức năng tương tự như hàm fetch() của JavaScript nhưng Axios nó hỗ trợ hẵn việc chuyển đổi về Json mà không cần
        chuyển đổi giống như hàm fetch
      https://www.npmjs.com/package/axios
      Những phần liên quan đến việc gọi API thì đặt trong phần action
        try {
          var result = await axiosInstance.get(`/post/getListPagination.php?pagesizee=${pagesize}&currPage=${currPage}`);
          console.log("result=", result); 
        } catch (error) {
          console.error("error", error);
        }
        Có 2 lỗi đó là lỗi hệ thống và lỗi kiểu server. Lỗi kiểu server có nghĩa là server vẫn sử lý được nhưng mà nó sử lý khi mình gửi lên sai ->
          server vẫn sử lý thành công

    Post List API

    Post Item Content
      Trong quá trình gọi API thì sẽ bị chuyển đổi giữa 2 trạng thái là trạng thái chờ và trạng thái thành công. Ở trạng thái chờ thì chưa có 
        dữ liệu nên khi render ra nó sẽ là null nên khi render ra dữ liệu sẽ bị lỗi -> để tránh được lỗi này thì mình sẽ kiểm tra điều kiện
        v-if="post", để khi no chuyển đổi giữa 2 trạng thái với nhau thì nó sẽ không render ra khi post có trạng thái là null
        <div class="ass1-section__content" v-if="post">
            <p>{{ post.post_content }}</p>
            <div class="ass1-section__image">
                <router-link v-bind:to="{ name: 'post-detail', params: { id: post.PID } }">
                    <img v-bind:src="post.url_image" v-bind:alt="post.post_content">
                </router-link >
            </div>
        </div>

    Moment - Post Head
      Vấn đề liên quan đến hiển thị time thì mình dùng plugin đó là Moment
      Moment npm
      https://momentjs.com/
      https://www.npmjs.com/package/moment
      https://momentjs.com/docs/#/i18n/changing-locale/
      moment.locale('vi');

    Filter Category
      Hiển thị các bài viết theo 1 danh mục bất kỳ nào đó
      API: getListByCategory.php?pagesize=3&currPage=1&tagIndex=7
      Để phần định dạng style nó chỉ được định dạng trong Component hiện thời của mình thì thêm từ khóa scoped vào cho thẻ style
        <style scoped>
      Khi click vào 1 Category nào đó thì nó sẽ nhảy tiếp sang trang chủ nhưng truyền thêm id và slug tên của Category đó
        Keywords: vietnamese to url javascript -> tạo 1 helper
      Dynamic Route Matching: Lắng nghe sự thay đổi của URL, phần lắng nghe này chỉ chạy khi mà ta tương tác trên cùng 1 Component
      Không phải lúc nào mình cũng nhận được gia trị query vì có cả trường hợp giá trị query là rỗng. Kiểm tra giá trị id có giá
        trị hay không:
        Có giá trị thì gọi đến API getListPostByCategory, còn không có giá trị thì gọi đến getListPostHasPaging

    Optimize - Loading

    LoadMore Post
      Giống như trường hợp phân trang, khi load lần đầu tiên thì chỉ load 1 số lượng bài viết nhất định
      TH nếu current = 1 -> thay thế array listPosts mới
      TH nếu current = 2, 3, 4 -> đẩy thêm dữ liệu vào array listPosts( nối 2 array lại với nhau)
      if(NaN), if(null), if(undefined) đều trả về giá trị false
      Mỗi khi có sự thay đổi của router thì sẽ tiến hành thay đổi lại giá trị của tagIndex đồng thời reset currPage = 1
        watch: {
            $route(to, from) {
                this.tagIndex = to.query.tagIndex;
                this.currPage = 1;
            }
        },
      wath $route chỉ chạy khi có sự thay đổi router
        Lần load đầu tiên -> $route không chạy
        Ở lần laod đầu tiên:
          created() {
              var tagIndex = this.$route.query.tagIndex;
              this.$store.dispatch('post/getListPostHasPaging', { tagIndex });
          }
      Khi chuyển đổi qua lại giữa các router thì gọi đến api khác nên phải reset lại current page là 1
      this.getListPostHasPaging({ tagIndex });
        Nếu nhảy ra homepage thì tagIndex là undefined
        Nếu nhảy ra homepage mà có query thì tagIndex có giá trị
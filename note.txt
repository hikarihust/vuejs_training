<VirtualHost *:80>
  ServerAdmin proj_news.xyz
  DocumentRoot "C:/xampp/htdocs/vuejs"
  ServerName proj_news.xyz
  ErrorLog "logs/proj_news.xyz-error.log"
  CustomLog "logs/proj_news.xyz-access.log" common
</VirtualHost>

========================================== Cài đặt môi trường ==========================================

Cài đặt nodeJs. Khi cài đặt nodeJs thì sẽ có sẵn npm
Trước khi cài đặt thì kiểm tra xem nodeJs đã được cài đặt hay chưa bằng cách dùng câu lệnh node -v, npm -v
	trên PowerShell
Git -> Để Deploy mã nguồn lên server(sử dụng các hosting free)

========================================== Vuejs cơ bản ==========================================
Tìm hiểu về Vue Instance:
  Nghiên cứu cách tích hợp Vuejs vào trong 1 phần dự án đã tồn 
  Tích hợp Vuejs
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.18/vue.min.js"></script>
  Vue Instance là 1 thực thể Vue hay đối tượng Vue dùng để quản lý một thành phần trong trang web
  Khi tạo 1 Instance thì cần truyền vào 1 đối tượng để khai báo các thông tin liên quan như là: Đối tượng Instance
    đó quản lý thành phần nào
  Data and Methods:
    Data: Dữ liệu giành cho thành phần mà nó quản lý
  
Ràng buộc dữ liệu một chiều với Data Binding:
  Keywords: Template Syntax
  Đối với js khi sử dụng trong Vuejs sẽ có 1 số chú ý khi viết dấu {{}} đó là chỉ sử dụng được các biểu thức đơn giản
    như cộng trừ nhân chia, toán tử 3 ngôi thay thế cho biểu thức điều kiện, hay là sủ dụng các Methods của js cung
    cấp sẵn;
    {{ number + 1 }}
    {{ ok ? 'YES' : 'NO' }}
    {{ message.split('').reverse().join('') }}
  Không sử dụng được trong các trường hợp như là khai báo biến, hay sử dụng các câu lệnh điều kiện if-else

Sử dụng v on xử lí sự kiện người dùng: Cách sử dụng và cách khai báo Event trong Vuejs

Cách sử dụng Event Modifiers:
  stop và prevent
  Có thể viết bằng Javascript thông thường, tuy nhiên thì nếu sử dụng Event Modifiers thì sẽ giảm được 1 số đoạn code 
    thường lặp đi lặp lại trong quá trình sử lý
  Khi làm ứng dụng 1 trang Single Application thì Form cần phải được xử lý riêng, khi người dùng nhấn nút submit thì
    không cho trang chuyển hướng đến trang khác mà sẽ tạm dừng ở đó, sử lý dữ liệu trực tiếp bằng js sau đó sử dụng các
    công cụ khác để tương tác với server và gửi dữ liệu sang server.
  Để khi submit form mà nó không chuyển trang đi thì ở trong js có 1 khác niệm rất quen thuộc đó là preventdefault
  stopPropagation: Ngăn chặn sự kiện của phần tử con lan tỏa ra phần tử cha
Key Modifiers: Thường sử dụng với các ô input
  Chẳng hạn như trong form có input submit, thì trong trường hợp này khi mình nhập vào form rồi nhấn Enter thì nó sẽ chạy
  Thay cho việc dùng keycode để kiểm tra nhấn nút Enter thì có thể viết:
    <input v-on:keyup.enter="submit">
  Cũng kiểm tra tương tự thì có thể kiểm tra việc nhấn 
  enter, tab, delete (captures both “Delete” and “Backspace” keys), esc, space, up, down, left, right...
Tìm hiểu về Computed:
  Đối với Template của Vuejs {{}} thì sử dụng khá thuận lợi, tuy nhiên chỉ nên dùng trong các trường hợp mà biểu thức
    của mình là đơn giản, đối với các trường hợp mà biểu thức phức tạp thì không nên đặt ở phía Template mà nên sử dụng các
    thuộc tính hay method để thực hiện các logic
  computed là 1 thuộc tính trong object truyền vào đối tượng Vue. Computed có nhiều thuộc tính bên trong mà mỗi 1 thuộc
    tính là 1 function, các function này được tính toán dựa vào các dữ liệu có sẵn
    Ở đây thì nếu dùng method thì khi gọi đến ở Template thì cần phải có lời gọi hàm đi cùng nghĩa là cần có dấu ()
  Sự khác của method so với computed đó là khi sử dụng method thì phát sinh ra vấn đề đó là sô s lượng method sẽ được run 
    không mong muốn, có nghĩa là sẽ chạy bị thừa. Nếu mà khi thao tác với dữ liệu lớn thì sẽ làm giảm tốc độ chương trình.
    Do đó trong trường hợp này sẽ sử dụng computed
    <button v-on:click="a++"> A=A+1 </button>
    <button v-on:click="b++"> B=B+1 </button>
    <p>Number + A = {{ addA() }}</p>
    <p>Number + B = {{ addB() }}</p>
  Giải thích:
    Khi sử dụng method thì trong Template sẽ dùng lời gọi hàm, khi có bất kỳ 1 sự thay đổi nào thì Vuejs nó sẽ render lại
      Template do đó khi gặp lời gọi hàm nào thì nó sẽ luôn luôn chạy hàm đó.
    Đối với computed thì tuy khai báo giống như 1 hàm tuy nhiên thì nó sẽ được lưu vào đối tượng Vue, và hàm này chỉ được
      thực thi khi mà dữ liệu trong hàm đó có sự thay đổi
  => method thì sử dụng khi tính toán dữ liệu nó không dành riêng cho data, computed được dùng dựa trên dữ liệu của đối
    tượng Vue
Ràng buộc dữ liệu 2 chiều:
  <div id="app">
      <h1>FirstName = {{ firstName }}</h1>
      <input v-on:keyup="handleKeyUp" type="text" placeholder="Nhap firstName">
  </div>
  Dàng buộc dữ liệu 2 chiều được thể hiện ở chỗ dàng buộc biến trong data của mình vào trong ô input và đồng thời ô input
    nó sẽ dàng buộc ngược lại dữ liệu của mình khi người dùng nhập vào
  Vue cung cấp 1 chỉ thị để có thể làm việc này nhanh hơn đó là v-model

Ràng buộc Class bằng VueJs:
  Một phần thường xuyên xuất hiện trong các yêu cầu khi sử dụng Javascript thuần tương tác với cấu trúc Dom đó là việc thay
    đổi Class và thay đổi Style của 1 phần tử
  Class hay Style thì bản chất nó cũng là 1 Attribute, nó là thuộc tính của phần tử Html
  Đối với 1 phần tử thì có thể có nhiều Class, Trong VueJs thì dùng 1 đối tượng để quản lý các class

Ràng buộc Style cho phần tử:
  Đối với style thì có 1 số lưu ý riêng khi tương tác với 1 số phần tử đặc biệt như:
    <div style="background-image: url('https://cdn.pixabay.com/photo/2017/03/02/08/58/background-texture-2110724__340.jpg')">

Render Template dùng biểu thức điều kiện:
  Dùng để render ra các phần tử Html nào đó theo điều kiện nhất định. Điều kiện chính là biểu thức của Javascript nó có thể theo
    biến lưu trong data hoặc biến được tính toán trong computed
  Bên cạnh việc sử dụng v-if, v-else thì có thể dùng v-show
  Khi dùng v-show thì các phần tử Html đều tồn tại trong cấu trúc DOM nó chỉ ẩn đi bằng style display:none Còn đối với v-if và v-else 
    thì nó sẽ remove luôn đi phần tử Html
Render Template dùng vòng lặp trong VueJs:
  Đối với vòng lặp để quản lý tốt được vị trí và thứ tự của các phần tử thì nên cung cấp cho VueJs 1 key để để phân biệt các phần tử 
    với nhau để phục vụ các logic như sắp xếp các phần tử, sort, filter... thì dùng đến 1 thuôc tính đó là key

Lưu ý về Loop và Condition trong VueJS: Tìm hiểu độ ưu tiên của v-for so với v-if khi sử dụng chúng chung với nhau
  Xét về độ ưu tiên thì vòng v-for có độ ưu tiên cao hơn v-if
    <div class="user" v-for="user in arrUser" v-if="user.isActive">{{ user.email }}</div>
  Đối với trường hợp này nên tạo ra 1 computed được tính toán dựa trên thông số isActive để lọc ra những user nào có trạng thái là
    active

Lưu ý quan trọng về Array và Object trong VueJs: Vấn đề quan trọng và nó thường gây ra lỗi khi ta tương tác với VueJS thông qua object
  và array
  Đối với 1 số hàm có sãn của array như: push(), pop(), shift(), unshift(), splice(), sort(), reverse()
    -> Khi sử dụng hàm này để thêm, sửa, xóa các phần tử ở trong thì hệ thống phản ứng sẽ hoạt động và render lại. Nếu không thực hiện
    bằng cách sử dụng các phương thức này mà gán theo các cách thông thường thì các giá trị thay đổi không được render lại trên view
  Muốn thực hiện thay đổi theo cách thông thường như vậy thì dùng 1 hàm có sẵn của VueJs đó là $set()
    app;
      Vue {_uid: 0, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: Vue, …}
    app.arrNumber;  
      (6) [1, 2, 3, 4, 5, 6, __ob__: Observer]
    app.arrNumber.push(7);
      7
    app.arrNumber
      (7) [1, 2, 3, 4, 5, 6, 7, __ob__: Observer]
    app.arrNumber[7]
      undefined
    app.arrNumber[7]=2000;
      2000
    app.arrNumber[0]=2000;
      2000
    app.$set(app.arrNumber, 0, 3000);
      3000
  Trong trường hợp thay đổi thành 1 object mới thì ok bởi vì địa chỉ cũng thay đổi, thì lúc này hệ thống phản ứng sẽ giám sát địa chỉ đó
    app.objScore;
    {__ob__: Observer}math: 7.5__ob__: Observerdep: Dep {id: 4, subs: Array(1)}value: {__ob__: Observer}vmCount: 0__proto__: Objectget math: ƒ reactiveGetter()set math: ƒ reactiveSetter(newVal)__proto__: Object
    app.objScore.english=10;
    10
    app.objScore = {math: 7, english:8}
    {__ob__: Observer}
  Thêm 1 phần tử bằng cách dùng $set -> sẽ được hệ thống phản ứng giám sát sự thay đổi
    app.$set(app.objScore, 'physics', 8);
      8

                                =======================================================================
                                              Demo bài tập thực hành tổng hợp số 01

Phân tích data và Xử lí Price
Xử lý Change Color
  Xử lý sự kiện khi người dùng Click vào màu sắc nhất định
  Thường thì khi sử dụng vòng lặp for thì sẽ dùng đến key gắn vào cho các phần tử Html
Sử dụng v html trong Vue
  Render ra Html danh sách đặc tính của sản phẩm
  Render ra được mã nguồn Html trong 1 đoạn text

                                =======================================================================
Giới thiệu và cài đặt Vue CLI
  Cách cài đặt 1 cấu trúc thư mục cơ bản để xây dựng 1 dự án theo mô hình Single Page Application
  Dùng để xây dựng nhanh 1 cấu trúc thư mục để quản lý mã nguồn
  CLI: Command Line Interface
  Keywords: vuejs Template webpack -> https://github.com/vuejs-templates/webpack
  Để chạy các câu lệnh để có thể cài đặt thì cần phải đảm bảo đã cài đặt nodeJs và npm
    $ npm install -g vue-cli: -g là chữ viết tắt của global, cài đặt vue-cli ở trong tầm vực global, mình ó thể sử 
      dụng nó ở bất kỳ nơi nào trong máy tính để tạo ra 1 cấu truc thư mục mẫu
    $ vue init webpack my-project: my-project chính là tên của dự án
      $ vue init webpack-simple helloVueJs
      ? Project name (helloVueJs) hello
      ? Project name hello
      ? Project description (A Vue.js project)
      ? Project description A Vue.js project
      ? Author (vudinhquang <vudinhquangk53@gmail.com>)
      ? Author vudinhquang <vudinhquangk53@gmail.com>
      ? License (MIT)
      ? License MIT
      ? Use sass? (y/N) n
      ? Use sass? No
        vue-cli · Generated "helloVueJs".
        To get started:
          cd helloVueJs
          npm install
            Cài đặt các thư viện khác mà nó sử dụng trong VueJS. Coi trong package.json, nó khai báo 
              tất cả các thư viện phụ thuộc vào bên ngoài
            Sau khi chạy câu lệnh này xong thì trong thư mục của mình có thêm thư mục là node_modules trong đó
              chứa tất cả các thư viện mà chúng ta có sử dụng
          npm run dev
            Câu lệnh này sẽ sinh ra 1 server ảo: http://localhost:8081/
    $ cd my-project
    $ npm install
    $ npm run dev
Cấu trúc Project, tìm hiểu Webpack và Babel
  Tìm hiểu về 1 số thành phần được tạo ra sau khi cài đặt cấu trúc thư mục
    package.json: Là nơi khai báo các thư viện, module ở bên ngoài mà mình sử dụng trong project
  Có 2 môi trường:
    Development: Là môi trường dành cho lập trình viên
      "devDependencies": {
        "babel-core": "^6.26.0",
        "babel-loader": "^7.1.2",
        "babel-preset-env": "^1.6.0",
        "babel-preset-stage-3": "^6.24.1",
        "cross-env": "^5.0.5",
        "css-loader": "^0.28.7",
        "file-loader": "^1.1.4",
        "vue-loader": "^13.0.5",
        "vue-template-compiler": "^2.4.4",
        "webpack": "^3.6.0",
        "webpack-dev-server": "^2.9.1"
      }
      -> Dùng trong quá trình lập trình
        Babel là 1 trình biên dịch của Javascript
        ES6:
          let name = 'join';
          const age = 28;
          let str = `My name is ${name}`;
          class Person {
            constructor(name = '', age = 28) {
              this.name = name;
              this.age = age;
            }
          }
          var arr1 = [1, 2, 3];
          var arr2 = ['abc', 'def'];
          arr = [...arr1, ...arr2];
    Production: Public ra cho user sử dụng
      "dependencies": {
        "vue": "^2.5.11"
      }
      -> Dùng xuyên suốt trong quá trình user dùng trang web của mình
  Webpack: Công cụ giúp đóng gói code, đóng gói mã nguồn
    Khi đẩy code ở dạng môi trường Production thì sẽ build ra bằng câu lệnh: npm run build lúc này sẽ sinh ra 1 
      thư mục nữa chính là thư mục chứa file Javascript cuối cùng đã được đóng gói. Để đóng gói được thì cần phải có
      webpack
    Lệnh: $ npm run build

Cấu trúc Project và Cấu hình cơ bản Webpack: Cấu hình lại thông tin cơ bản để phục vụ quá trình lập trình
  https://webpack.js.org: Xem hướng dẫn cách config
  index.html là file được chạy đầu tiên, trong đó có 1 đối tượng <div id="app"></div>, đối tượng Vue để quản lý app đó
    là nằm trong main.js thuộc folder src
  import Vue from 'vue' thực hiện import thư viện vue từ bên ngoài vào, thư viện này được khai báo ở trong package.json
    "dependencies": {
      "vue": "^2.5.11"
    },
   App from './App.vue'
    Trong đây là nơi khai báo toàn bộ mã nguồn, có 3 thành phần chính: template, script(Javascript), style để viết Css
    script:
      export default {
        name: 'app',
        data () {
          return {
            msg: 'Welcome to Your Vue.js App'
          }
        }
      }
    -> main.js là nơi sẽ import
    Mỗi thành phần trong Web tương ứng với mỗi component -> Tương ứng với 1 file *.vue
  Extension: 
    Keywords: Vue -> Vetur, khi cài đặt xong thì sẽ xem được cú pháp của App.vue dễ nhìn hơn
  Webpack là công cụ để đóng gói, do đó khi build thì có thể cấu hình lại nó chẳng hạn như vị trí index.html, tên thư mục
    có để đổi từ dist sang tên khác, hay vị trí của file ảnh logo.png cũng vậy
    -> webpack.config.js Là nơi để cấu hình webpack, để khai báo các thông tin liên quan đến trang web
    entry: './src/main.js', main.js là file nó sẽ chạy lần đầu tiên
    output: {
      path: path.resolve(__dirname, './dist'),
      publicPath: '/dist/',
      filename: 'build.js'
    },
      -> Đóng gói sẽ xuất ra ở đâu
      publicPath: '/dist/' là đường dẫn sẽ đóng gói ra bên ngoài
  
  Sau khi config xong thì gõ lệnh: npm run build, chạy xong câu lệnh này thì sẽ sinh ra được thư mục mới(dist), có thể thay
    đổi tên tùy ý
  loader: 'file-loader', là công cụ dùng để quản lý hình ảnh và đóng gói hình ảnh
    "devDependencies": {
      "babel-core": "^6.26.0",
      "babel-loader": "^7.1.2",
      "babel-preset-env": "^1.6.0",
      "babel-preset-stage-3": "^6.24.1",
      "cross-env": "^5.0.5",
      "css-loader": "^0.28.7",
      "file-loader": "^1.1.4",
      "vue-loader": "^13.0.5",            -> Để thông báo vue.js là file hợp nệ
      "vue-template-compiler": "^2.4.4",
      "webpack": "^3.6.0",
      "webpack-dev-server": "^2.9.1"
    }
    https://webpack.js.org/loaders/file-loader/#root
    options:
      name: '[name].[ext]?[hash]'
        ->
        name: function(file) {
          return '/images/[contenthash].[ext]';
        }

Tìm hiểu Component và cách tạo trong Vue: Cách xây dựng 1 component mới kết nối các component lại với nhau để tạo ra một 
  trang web hoàn chỉnh
  Mỗi component chứa đựng 1 thành phần trong trang web, mỗi component được quản lý bởi 1 file *.vue, do đó thì khi mà mình
    muốn tạo ra bao nhiêu component thì tạo ra bấy nhiêu file *.vue
  Cách xây dựng component thì nó sẽ có cấu trúc giống như cấu trúc html
    App
      Header 
      ListProduct
        Product
        Product
        Product
        Product
      Footer
  Mỗi Component có cấu trúc 3 phần
    template: Để viết mã nguồn html
    script: export default ra 1 object, object này giống với đối tượng Vue
    style: Nếu như component có CSS riêng thì sẽ viết ở đây
  Khi muốn sử dụng 1 component ở trong 1 component khác thì ngoài việc phải import vào thì cần phải đăng ký 
    trong component mà nó sử dụng
      Keywords: Single File Components
        components: {
          OtherComponent
        }

Cài đặt mã nguồn và tổ chức Component lồng nhau
  Khi chia sẻ các source code giữa các máy tính với nhau thì sẽ không chia sẻ tập tin node_modules mà thư mục
    này chỉ được sinh ra trong nội bộ máy tính của mình mà thôi.
    npm install -> node_modules
    public/  -> Đóng gói khi đẩy code lên môi trường Product để cho người dùng sử dụng

Tìm hiểu Props Down trong Vue
  Keywords: props
  Cách để truyền dữ liệu giữa các component với nhau
  props Là những Data, những dữ liệu mà mình sẽ truyền từ component cha vào component con
    -> Sử dụng cú pháp giống với thuộc tính, thuộc tính này là thuộc tính mà mình tự đặt ra -> Ràng buộc thuộc
      tính -> Sử dụng chỉ thị v-bind để ràng buộc dữ liệu vào trong thuộc tính này
  Khi khai báo sử dụng props rồi thì sử dụng nó giống như 1 data thông thường
  Đối với props khi không quy định gì cả thì có nghĩa là có thể truyền vào hoặc không và khi đó cần phải định 
    nghĩa dữ liệu mặc định
  Giả sử không truyền props thì cũng ko
  Demo: App chứa các thông tin: title, listArray[]
        title truyền vào cho CompHeader và CompFooter, truyền listUser vào cho ListUser
          Trong ListUser Component nhận được mảng giá trị ListUser truyền từ App sẽ tiếp duyệt từng user và truyền
            vào User Component
    -> Toàn bộ dữ liệu được quản lý ở App Component

Tìm hiểu Event Up trong Vue:
  Tìm hiểu cách truyền 1 thông điệp từ component con ra component cha để gửi thông báo muốn thay đổi dữ liệu từ component 
    cha
  Keywords: Custom Event trong Vuejs
  Tìm cách tương tác với dữ liệu
  Demo: 
    App.vue:
      <template>
        <div id="app">
          <!-- <CompHeader></CompHeader>
          <CompHeader /> -->
          <!-- <comp-header v-bind:titleHeader="title"/> -->
          <div class="container">
            <button v-on:click="title = 'Học lập trình Vuejs'">Thay đổi title từ Component App.vue</button>
            <comp-header v-bind:title="title"/>
            <list-user v-bind:listUser="listUser"/>
            <comp-footer v-bind:title="title"/>
          </div>
          <!-- <comp-footer/> -->
        </div>
      </template>
    Tại App.vue thì khi nhấn vào buttom thì thực hiện thay đổi title -> Khi đó thì hệ thống phản ứng sẽ hoạt động
    -> Component Header và Component Footer đều nhận được sự thay đổi đó
    Phần thực hiện này nó liên quan đến Props Down. Props là dữ liệu của cha truyền vào nên nó truyền xuống tất cả các 
      component con bên trong có sử dụng -> tự động phản ứng lại, render lại giao diện bất kỳ khi nào component cha(quản
      lý title) thực hiện thay đổi title.
  Trong thực tế có thể có nhu cầu phức tạp hơn đó là việc click thay đổi title ở trong Header Component. Trong trường
    hợp này thì không được phép thay đổi props trực tiếp từ trong component con. Về nguyên tắc thì props được truyền 
    từ component cha nên chỉ component mới có thể thay đổi
  Đây là 1 phần rất quan trọng bởi vì khi làm các dự án lớn thì sẽ lồng rất nhiều component lại với nhau, để tương tác giữa
    các component đó thì phải biết cách Event Up và Props Down
  Props Down -> Dùng để truyền dữ liệu từ cha vào con -> Thằng con chỉ được dùng thôi chứ không được thay đổi trực tiếp
    Component nào nắm giữ data thì chỉ có component đó có thể thay đổi thôi. title đang do App.vue nắm giữ nên chỉ App.vue
      mới có thể thay đổi thôi
  Event Up -> Truyền thông điệp(sự kiện) để thông báo cho component cha biết là nó muốn thay đổi dữ liệu -> Nhiệm vụ 
    của component cha là nhận được thông điệp và tiến hành thay đổi data.
    Việc gửi thông báo đó nó là mình sẽ tạo ra 1 sự kiện
    -> Phần này liên quan đến Custom Event trong Vuejs

    click -> Là sự kiện có sẵn trong VueJs, để khai báo click thì sử dụng từ khóa v-on:click="changeTitle"
      -> Phân dã ra làm nhiều thành phần nhỏ:
        'click' -> Tên của sự kiện
        'changeTitle' -> Hàm xử lý khi sự kiện được kích hoạt, có nhiều dạng sự kiện khác nhau. Đối với sự kiện click thì
          nó sẽ được kích hoạt khi người dùng click
  Tự tạo ra 1 sự kiện mới và tự đặt tên cho sự kiện đó, và định nghĩa khi nào nó được kíck hoạt, ở đây nó được kích hoạt
    thông qua những đoạn code(các sự kiện có sãn trong Vuejs thì nó được kích hoạt thông qua sự tương tác của người dùng)
    -> Để kích hoạt được thì dùng từ khóa là $emit -> gọi ở trong component con
  Khi dùng các sự kiện mặc định như click... thì nó đã truyền sẵn cho mình 1 biến $event, tuy nhiên khi tự tạo ra 1 sự kiện
    mới thì dữ liệu đó sẽ truyền vào tham số thứ 2 của $emit(); và e này là 1 đối tượng mình tự tạo ra(các sự kiện như
    click thì là do Javascript tạo)
  Demo Xóa user: Tạo thêm nút nhấn cho các user có chức năng xóa user
    Khi click vào nút nhấn delete thì cần phải truyền thông điệp ra ngoài App để nó có thể xóa được 1 phần tử nhất định
    Trong trường hợp này thì cấp độ nâng cao hơn trường hợp thay đổi title tại vì user không phải được gọi trực tiếp từ App
      Mà User component lại được gọi từ ListUser component
    Xét về mô hình truyền event:
      App -> truyền arrUser vào cho ListUser, tại đây ListUser component sẽ chạy vòng for để render ra từng user -> truyền 
        vào User component.
      Như vậy thì tại User component truyền event thông báo ra cho ListUser, bởi vì ListUser không phải component nắm giữ
        arrUser mà do App component nắm giữ. Do đó ListUser này cũng không được quyền thay đổi arrUser -> Tiếp tục truyền 
        tiếp event thêm 1 lần nữa ra ngoài App component, công việc truyền này chỉ thực hiện khi nó nhận được thông báo từ
        User component -> Thực hiện xóa tại App component
      splice(): Dùng để xóa đi 1 phần tử trong mảng
        array.splice(index, howmany, item1, ....., itemX)
          index: Vị trí xóa từ phần tử nào
          howmany: Xóa bao nhiêu phần tử
        Trả về danh sách đã xóa 

Sử dụng Ref trong Vue(Reference)
  Reference là 1 biến dùng để tham chiếu đến các phần tử html mà mình muốn sử dụng nó cho 1 mục đích của Javascript
  <input type="file"> -> Rất khó để có thể thay đổi được giao diện của nó, nên thông thường ở trong Javascript thuần người
    ta thường tạo ra 1 bản sao của nó bằng 1 html(buttom) khác dễ code hơn, dễ viết css hơn, dễ làm cho giao diện hơn, khi người ta
    bắt sự kiện click để có thể chọn 1 file từ máy tính thì người ta sẽ bắt sự kiện click thông qua nút(buttom) nhấn đó, thực ra nút 
    input type="file" này thực sự đã ẩn bên cạnh rồi
  Để chọn được avatar thông qua nút mà mình đã tạo bằng html(buttom) thì lúc này sẽ sử dụng Reference
  handleClickInputFile() có chức năng gọi sự kiện click vào ô input, thay vì người dùng trực click vào nút này thì mình sẽ click nó
    bằng code, truy cập vào input type="file" thông qua biến toàn cục refs của ô input đó.
    Do đó lúc này khi click vào buttom thì mình có thể chọn được avatar mặc dù đã ẩn input type="file"

Tìm hiểu Slot và bài tập ứng dụng: Cách sử dụng slot trong VueJs thông qua các ứng dụng thực tế
  Đối với props thì nó chỉ truyền vào cho component con những giá trị với kiểu dữ liệu cơ bản như string, number, array, object
  Khi muốn truyền 1 cấu trúc html vào cho component con thì việc này Slot có thể làm được
  Slot được sử dụng trong trường hợp mình muốn kế thừa 1 phần nào đó của component
  Demo: Ứng dụng các slot trong thực tế dùng để kế thừa lại và tăng tính sử dụng lại của 1 component
    Xây dựng 1 component để hiện thực 1 tab, phía trên là tiêu đề của tab nhận string của component cha truyền vào và 1 
      icon -> tiêu đề này thì có thể dùng props để truyền dữ liệu từ component cha sang component con
      Trong component con thì nội dung được kế thừa từ component cha được đặt ở vị trí của cặp thẻ <slot></slot>
    Phần dưới là phần dành cho tab gồm có danh sách nhiều tab, phía dưới là nội dung của tab đó. Khi click vào tab nào thì nội
      dung của tab đó sẽ được hiển thị
    Icon: ionicons
      https://ionicons.com/usage
    Tùy vào trường hợp mà sẽ hiển thị lên nội dung của tab tương ứng -> do đó cần có 1 biến nào đó để nhận diện hiện tại nó
      đang show tab nào
    Xử lý sự kiện click, khi click vào tab nào thì sẽ hiển thị tab tương ứng
    Khi tab nào được active thì tab đó có thêm class là active -> dàng buộc dữ liệu vào class
  
Tìm hiểu về Life Cycle: Vòng đời của 1 đối tượng Vue kể từ khi nó được khởi tạo cho đến khi nó được remove khỏi cấu trúc DOM
  https://vuejs.org/v2/guide/instance.html#Lifecycle-Diagram
  VueJs đã tạo sẵn 1 số function như: beforeCreate(), created(), beforeMount(), mounted(), beforeUpdate(), updated(), 
    beforeDestroy(), destroyed()
  Các function này VueJs tạo sẵn cho ta chèn vào giữa quá trình hoạt động của nó để có thể sinh ra các mã code trong đó xen
    giữa vào quá trình hoạt động từ trên xuống dưới của 1 đối tượng Vue
  Thứ tự run của các hàm này:
    beforeCreate() -> created() -> beforeMount() -> mounted
  beforeCreate(): Được chạy khi đối tượng Vue được khởi tạo và bắt đầu khởi tạo ra được vòng đời, Trước khi hệ thống phản
    ứng hoạt động
    Do đó tại function này thì khi truy xuất vào các data của component thì sẽ trả về là undefined bởi vì ngay tại thời điểm
      đó đối tượng Vue chưa xây dựng hệ thống phản ứng mà kể từ hàm created() trở đi thì có thể truy xuất được vào tất cả các
      data của component
  created(): Khi đối tượng Vue đã xây dựng xong hệ thống phản ứng, lúc đó toàn bộ dữ liệu có thể truy xuất được rồi thì sẽ
    thực thi hàm created()
    Là nơi thường truyền các đoạn code như gọi API, Call Ajax để lấy dữ liệu từ server về
  Việc compile(biên dịch) template html ra cấu trúc DOM, cho đến hàm mounted() thì toàn bộ cấu trúc DOM mới hiển thị ra Html
    Do đó thì cho đến đi vào hàm mounted() thì mới có thể truy xuất được vào cấu trúc DOM
    Do đó thì chỉ trong hàm mounted() trở đi mình mới có thể dùng các thư viện liên quan đến jQuery, Javascript thông thường
      để truy xuất DOM để thực hiện hành động nào đó tương tác với cấu trúc DOM
  beforeDestroy() và destroyed() được chạy khi đối tượng Vue bị hủy bỏ
  beforeUpdate() và updated() được chạy khi có bất kỳ 1 sự thay đổi nào đó về dữ liệu. Hàm beforeUpdate() được chạy trước, rồi
    sau đó mới chạy updated()
    Được dùng để bắt việc có sự thay đổi dữ liệu, có thể ứng dụng viết sử lý cho việc sau khi thay đổi dữ liệu xong thì 
    sẽ làm gì tiếp...
  -> Hàm hay được sử dụng đó là created() và mounted()

========================================== Xây dựng Game đổ xúc xắc ==========================================

Phân tích kĩ thuật và dữ liệu
  <div class="spinner dice-3"> Dùng để thay đổi xúc xắc bằng cách thay đổi số, đối với vấn đề này thì có thể sử dụng việc dàng
    buộc class trong VueJs -> Ramdom ra 1 con số rồi truyền vào class trên dice-*
  Active: Khi đến lượt người nào chơi thì người đó sẽ được active(được thêm class là active), đến khi có 1 người nào chiến thắng
    thì class active sẽ được thay bằng class winner và tên người chơi cũng được sửa lại là Winner
  Các hành động: Có các hành động đó là new game, rolldice, hold
  Các dữ liệu cần lưu: Lưu thông tin điểm chính thức, điểm tạm thời. Điểm tạm thời là điểm được cộng dồn mỗi lần người dùng đó
    xoay xúc xắc. Khi người dùng nhấn vào nút lấy điểm(hold) thì lúc đó điểm tạm thời đó mới được cộng vào trong điểm chính thức.
    Khi xoay xúc xắc thì phải có các con số để đại diện cho nó.
    Ngoài ra thì cần phải bắt thêm 1 sự kiện nữa đó là khi nào thì người ta bắt đầu chơi -> cần có 1 biến để nhận diện, khi chưa 
      click vào nút New Game thì có giá trị false và click vào nút New Game thì có giá trị là true
    Nhận diện xem người đã đã bắt bắt đầu chơi hay chưa(khi fresh lại trang là chưa bắt đầu chơi), nếu chưa bắt đầu chơi thì cần 
      hiện thị ra câu thông báo đó là "Vui lòng nhấn New Game"
    Khi nhấn vào New Game thì cho hiện lên modal(popup) để hiển thị luật chơi -> cần có 1 biến để nhận diện khi nào thì popup này được 
      hiển thị
    Phải nhận diện được ai là người đang chơi activePlayer khi có giá trị 1 thì có nghĩa là người thứ nhất đang chơi, có giá trị 2 có
      nghĩa là người thứ 2 đnag chơi
    -> Các dữ liệu: score, currentScore, dice1, dice2, isPlaying, activePlayer
  Khi nhấn vào nút New Game:
    1. Show popup
    2. Reset lại Data
    3. Xây dựng popup
  Khi click vào nút Roll Dice để xoay xúc xắc
    1. Random dữ liệu 2 con xúc xắc
    2. Kiểm tra xem người dùng có quay trúng con số 1 hay không?
      Nếu xoay chúng số 1 -> đổi lượt chơi -> Reset điểm tạm thời
      Nếu xoay ok -> Cộng dồn vào điểm tạm thời cho người chơi đó  
  Hold -> lấy Điểm
    So sánh xem điểm cuối cùng có lơn hơn FinalScore hay không? nếu lớn hơn thì người đó chiến thắng
    Chưa đủ điểm -> Cộng dồn điểm chính thức -> Đổi lượt chơi

Tích hợp giao diện vào Vue
  Từ thư mục gốc ban đầu đó là HelloVueJs tạo thêm folder mới đó là DiceGame_Vue
  Gõ lệnh npm install để cài đặt các gói hỗ trợ
  npm run dev
  Xóa đi các component không cần thiết mà ban đầu mình đã copy từ HelloVueJs
  Khi tích hợp giao diện vào Vue thì các hình ảnh mình sẽ lưu vào trong thư mục assets và assets này được tính
    từ public
    output: {
      path: path.resolve(__dirname, './public'),
      publicPath: '/public/',
      filename: 'build.js'
    },
    {
      test: /\.(png|jpg|gif|svg)$/,
      loader: 'file-loader',
      options: {
        // name: '[name].[ext]?[hash]'
        name: function(file) {
          return 'assets/[name].[ext]?[hash]';
        }
      }
    }
    -> Định dạng url cho các file hình ảnh url('/public/assets/back.jpg');
    Các tấm hình này thì minhf sử dụng luôn nên ko cần để trong thư mục src/assets, các tấm hình ở trong src/assets
      thường sẽ là import hoặc là khai báo trực tiếp ở trong html. 
    Khi gõ lệnh npm run build thì các tài nguyên js và các tài nguyên nằm trong public/assets do đó trong phần CSS
      trong App.vue cần trỏ đến public/assets bởi vì đoạn CSS này khi hiển thị lên Vue thì sẽ được khai báo trong thẻ
      style của index

Xây dựng các Component cần thiết: 
  Tiến hành tách ra thành các component nhỏ hơn: Người chơi, các nút control, cục xúc xắc
  Khi tiến hành tách components thì cũng tiến hành tách luôn CSS
  Players Component: Trong trường hợp này thì chỉ có 2 player nên ko cần tách ra thành các player components, trong 
    trường hợp có 1 danh sách các players thì nên tách

Xây dựng Logic dữ liệu cơ bản
  Các thông tin cần lưu: 
    Điểm của người chơi: Có 2 người chơi nên có thể lưu vào 1 mảng có 2 phần tử tương ứng với điểm của từng người chơi
      -> Truyền điểm vào Players Component thông qua props
    Điểm tạm thời: Điểm tạm thời này có sự luân phiên qua lại với nhau, khi lượt chơi thuộc về người nào thì người đó
      có điểm tạm thời, lúc này điểm tạm thời của người kia bằng 0 -> Không cần lưu bằng mảng mà có thể lưu bằng 1 biến
      đơn
    activePlayer: Dùng để nhận diện ai là người chơi hiện tại, người nào đang chơi thì người đó được active
      0: Người thứ nhất là người chơi hiện tại
      1: Người thứ 2 là người chơi hiện tại
    v-bind:class Khi dàng buộc dữ liệu vào trong class thì truyền vào 1 Object, key là tên class, value là điều kiện để 
      xảy ra class đó
    isPlaying: Kiểm tra xem có đang chơi game hay không

Chức năng New Game:
  Button New Game thì được đặt trong Control Component, tuy nhiên thì về việc xử lý thì phải xử lý trong App Component
   -> Áp dụng việc truyền dữ liệu từ Component con ra Component cha
  Hiển thị Popup để show luật chơi
  Kết hợp CSS3 với VueJS để xây dựng hiệu ứng - Zoom in - Zoom out -> Sử dụng hiệu ứng transform là scale
    Khi ở trạng thái đầu sẽ Zoom to popup, khi bật popup lên thì sẽ Zoom nhỏ lại, dùng transition để tạo hiệu ứng thay 
      đổi dần dần
  open-popup: Khi nó có class này thì popup được hiển thị lên và chạy hiệu ứng, để kết hợp với VueJs thì chỉ cần dàng 
    buộc class vào là được
  isOpenPopup: Xác định là khi nào thì sẽ hiển thị popup
    Popup được hiển thị khi người dùng click vào nút New Game. Khi click vào nút New Game thì đầu tiên Control.vue được chạy
      sau đó nó sẽ gọi hàm handleNewGame trong App.vue, tại đây thực hiện thay đổi isOpenPopup = true
    Khi click vào nút Đã hiểu nằm trên Popup thì sẽ bắt đầu cuộc chơi, Khi click vào nút Đã hiểu thì có nghĩa là người chơi
      đã đọc luật chơi rồi -> ẩn popup đi và Reset lại các thông tin đồng thời các con xúc xắc cũng reset về con số 1
  Đối với class trong VueJs thì có thể truyền vào 1 chuỗi cũng được:
    <div class="spinner" v-bind:class="'dice-1'">

Xây dựng chức năng Roll Dice: Chức năng xoay xúc xắc
  TH1: Khi người dùng chưa nhấn vào nút New Game mà nhấn vào nút RollDice
  TH2: Khi người dùng đã nhấn vào nút New Game
  -> Kiểm tra giá trị của biến isPlaying nếu là false tức là người ta chưa bắt đầu chơi, nếu là true thì mới chơi
  Mỗi con xúc xắc có giá trị từ 1 -> 6 do đó dùng hàm Math.random() để random dữ liệu rồi gán vào cho mảng dices
  Sau mỗi lần quay xúc xắc mà người chơi quay đúng phải 1 hoặc 2 con xúc xắc có giá trị là 1 thì dừng người chơi của người đó và 
    chuyển lượt chơi qua người còn lại và đồng thời điểm tạm thời của người chơi đó cũng phải Reset về 0 không thì thì tiến hành 
    cộng dồn điểm vào điểm tạm thời của người chơi đó
  Khi hiển thị ra thông báo người dùng đã quay trúng vào số 1 thì các con sắc phải được đảo xoay và chuyển đổi người chơi rồi
    -> setTimeout()

Xây dựng chức năng Hold Score: Chức năng lấy điểm
  Xét về mặt luật chơi thì người dùng có thể lấy điểm bất kỳ lúc nào sau khi mà xoay xúc xắc xong
  Kiểm tra xem ai là chơi hiện tại để cộng điểm tạm thời vào điểm chơi chính thức cho người đó
  activePlayer có giá trị là 0 và 1
  scorePlayer là 1 mảng lưu điểm của 2 phần tử -> có thể dùng trực tiếp activePlayer làm chỉ số để lưu điểm tương ứng của player
    đang chơi, nếu thực hiện theo kiểu gán thông thường this.scoresPlayer[this.activePlayer] += this.currentScore; thì giao diện
    nó không phản ứng lại cho mình
  Lưu ý: Khi tuownng tác vơi Array và Object thì cần phải cẩn thận ko nên thay đổi trực tiếp 1 phần tử nào đó của Array mà thay 
    đổi lại luôn địa chỉ của mảng bằng cách tạo lại 1 array mới hoàn toàn và Coppy dữ liệu từ Array cũ
    Keywords: Caveats
    -> Clone lại dữ liệu(spread operator)
  Khi đã cộng dồn xong thì cần phải đổi lượt chơi

Kiểm tra thắng cuộc:
  Việc đầu tiên là phải thu thập dữ liệu từ người dùng nhập vào trong ô input là Final Score, ai đạt được điểm này thì người đó
    là người chiến thắng
  Dùng đến việc ràng buộc dữ liệu 2 chiều
    Có 2 loại dàng buộc:
      1. Ràng buộc dữ liệu(thường dùng trong các thuộc tính html) -> v-bind. Ở đây thì mình chỉ ràng buộc ở bước đầu tiên thôi, khi
        load lại trang hoặc là khi nó Render html ra thì giá trị trong data sẽ được gán vào trong value và sau đó nếu như mà có bất
        kỳ sự thay đổi nào liên quan đến dữ liệu thì nó không có gán trực tiếp vào biến trong data
        -> Chỉ có 1 chiều từ data -> input thôi chứ ko có chiều ngược lại 
      2. Ràng buộc dữ liệu 2 chiều -> v-model
        1 chiều từ data -> input
        1 chiều từ input -> data
      Nếu như nó không phải là data trực tiếp của Component Controls -> Nó không được phép thay đổi
  Các dữ liệu mà mình thu thập từ 1 ô input thì nó đều ở dạng chuỗi(string)
  Về nguyên tắc thì props không được phép thay đổi trực tiếp ở trong Component con
  Thay thế v-model bằng v-bind kết hợp với v-on mà trong đó sự kiện ở v-on sẽ thực hiện việc thay đổi giá trị của data
    -> Sự kiện lắng nghe sự thay đổi dữ liệu
      v-on:input="$emit('handleChangeFinalScore', $event)"
      v-on:change="$emit('handleChangeFinalScore', $event)"
  Sau khi tiến hành việc truyền sự kiện thành công từ Component Control sang Component App thì tiến hành lấy dữ liệu Final Score 
    để gán vào cho data. Ở đây thì tất cả các dữ liệu lấy ở trong ô input ra đều là dạng chuỗi do đó cần phải ép kiểu về dạng số
    trước khi gán cho Final Score.
    Khi tiến hành ép kiểu 1 dạng chuỗi sang số mà bản chất nó ko phải là số thì nó sẽ ra giá trị NaN
  Warning: Invalid prop: type check failed for prop "finalScore". Expected Number with value 0, got String with value ""
    Đối với kiểu dữ liệu của 1 props mình truyền vào mình có quyền khai báo thành nhiều kiểu dữ liệu, thay vì nó là 1 kiểu giá trị
      thì mình có quyền khai báo là 1 mảng
  Khi click vào nút New Game để tiến hành chơi thì không cho người chơi sửa Final Score nữa
  Cuối cùng là tiến hành kiểm tra người chơi nào là người thắng cuộc thông qua việc so sánh điểm chính thức của họ với điểm Final
    Score mà mình đã thiết lập, khi có 1 người chiến thắng thì sẽ thay thế class active của người đó bằng class là winner đồng thời
    thay tên người trời thành WINNER -> sử dụng computed
  computed -> function đó sẽ tự động được chạy bất kể khi nào mà dữ liệu bên trong đó có sự thay đổi
  Dựa vào giá trị activePlayer thì có thể biết được ai là người chiến thắng ở thời điểm đó
  Khi có người chiến thắng thì dừng cuộc chơi
  Khi cộng điểm vào cho mỗi người chơi thì cần phải xác định xem có ai là người thắng cuộc hay không? Nếu có thì dừng cuộc chơi và
    không chơi được nữa nếu ko thì chuyển người chơi
  Khi khi có người chiến thắng thì bỏ class="active" của người đó đi và thay vào là class="winner" cho người chơi đó

========================================== Xây dựng Project Todolist =========================================

Chức năng là quản lý các công việc cần phải làm hằng ngày theo mức độ ưu tiên
Có các chức năng cơ bản như thêm, sửa, xóa, tìm kiếm, sắp xếp, Clear từ khóa tìm kiếm

Tích hợp giao diện và phân chia Component
  Sử dụng thư mục gốc là HelloVueJs rồi chạy câu lệnh npm install để cài đặt các gói thư viện rồi chạy câu lệnh npm run
    dev để chạy server ảo. Trong trường hợp này thay vì dùng câu lệnh npm install thì mình có thể dùng câu lệnh yarn install.
    Để có thể dùng câu lệnh này thì trước tiên mình có thể cài đặt bằng câu lệnh npm install -g yarn
    Nếu dùng yarn install thì quá trình cài đặt sẽ được tiến hành nhan hơn bởi vì nó được cài đặt dựa trên cơ chế song song
    còn npm install thì dựa trên cơ chế tuần tự
  1. Tích hợp giao diện Bootstrap
    Khi thực hiện các dự án theo kiểu Single Application thì không nên import các thư viện thô kiểu như: 	<link rel="stylesheet" href="css/bootstrap.min.css">
      mà thay vào đó là sử dụng node_modules để sau này khi build sản phẩm cuối cùng nó sẽ đóng gói lại cho mình 1 mã nguồn tốt hơn
    Ngoài ra thì có sử dụng jQuery <script src="js/jquery.min.js"></script> nên đây cũng là 1 lý do mình không nên import trực tiếp 
      tại vì cơ chế render của Single Application khác với cơ chế thông thường. Khi mình mở 1 web tĩnh, khi tải lên thì toàn bộ html
      đã được tải lên xong rồi. Còn đối với Single Application thì mình khai báo theo hướng Component cho nên sẽ có lúc các Component
      chưa load kịp cho nên sẽ có trường hợp các jQuery mình sử dụng sẽ bị lỗi cho nên phần Bootstrap 4 mình sẽ import thông qua npm
      chứ không dùng các câu lệnh script trong html
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <script src="js/jquery.min.js"></script>
        <script src="js/popper.min.js"></script>
        <script src="js/bootstrap.min.js"></script>
    Keywords: Bootstrap vue
    Site: https://bootstrap-vue.js.org/
      -> Using module bundlers
      yarn add vue bootstrap-vue bootstrap: Để cài đặt các các phiên bản mới nhất của Vue.js, BootstrapVue and Bootstrap v4:
        bootstrap: Tải về các file css hỗ trợ về mặt giao diện
        bootstrap-vue: Tạo sẵn cho mình các Component theo kiểu Vue được sử dụng dựa trên Bootstrap != Với việc sử dụng thuần html
        vue: Đã được mình cài đặt rồi nhưng version là version 2.5.11
        Sau quá trình cài đặt này thì vue cũng được nâng cấp lên phiên bản mới nhất
      Để có thể cài đặt Bootstrap theo kiểu VueJs thì tiến hành đăng ký các thư viện ở cấp toàn cục trong main.js để có thể sử dụng trong
        mọi Component con
        Vue.use(BootstrapVue): Để mình đăng ký plugin BootstrapVue đối với VueJs được sử dụng ở cấp toàn cục để có thể sử dụng mọi nơi
          trong các Component
      Import vào các file Css:
        import 'bootstrap/dist/css/bootstrap.css'
        import 'bootstrap-vue/dist/bootstrap-vue.css'
    -> Biết các cài đặt Vue, biết cách sử dụng thư viện của bên thứ 3, cách import bootstrap vào ứng dụng Single Application theo kiểu là 
      VueJs mà không import theo kiểu thông thường bằng thẻ <script> mà sử dụng công cụ BootstrapVue. Khi dùng theo cách thông thông thường 
        thì khi mình đóng gói public sản phẩm ra thì các mã nguồn khai báo ở file html nó sẽ không được đóng gói lại -> chức năng của 
        webpack không phát huy tác dụng. 
      Cần đóng gói lại code để quản lý tốt về thứ tự khai báo, thứ tự chạy plugin đồng thời do được đóng gói code nên ứng dụng của mình sẽ
        chạy nhanh hơn.
      Đối với các ứng dụng Single Application thì khi khai báo jQuery trong các file html rất nguy hiểm, có lúc chạy bị sai vì nó liên quan 
        đến thứ tự load Component. Trong trường hợp script jquery được load trước, sau đó Component mới được sinh ra -> dẫn đến vấn đề động
        độ về time -> Hạn chế sử dụng jquery theo kiểu khai báo script
  2. Bootstrap Vue
    Tổ chức lại cấu trúc thư mục.
    Trong các dự án thực tế thì phải khai báo nhiều plugin do đó mình nên tách ra thành 1 thư mục khác cho dễ quản lý
      -> Tạo thêm thư mục mới là plugins
    Mô hình quản lý:
      main.js -> import file index.js, file index.js này nằm trong thư mục là plugins. File main chỉ cần quản lý 1 mình file  này
      index.js -> Gọi toàn bộ các plugin khác bên ngoài
      bootstrap.js -> import các thư viện liên quan đến bootstrap
    Tính năng Sort by, mình khai báo nó là dropdown, để dropdown này chạy được thì nó có sự cam thiệp của Javascript hay nói cách khác là mình
      phải import jQuery vào thì nó mới chạy
      Do đó những Component nào liên quan đến bootstrap mà có sử dụng, có ứng dụng tới Javascript thì cần sử dụng các Component được tạo sẵn
        của BootstrapVue
    Không phải là chỉ các phần tử liên quan đến Javascript thì mới được dùng các Component BootstrapVue mà các phần tử bình thường cũng có thể
      dùng được như row, col...
      Keywords: Grid system
  3. Component: Tách Component App ra thành nhiều Component nhỏ hơn
    Tất cả các Component mình tạo ra thì khi đặt tên nên đặt từ 2 từ trở lên.
      Ví dụ như Component cho 1 phần là title thì ko nên đặt đơn là Title vì nó dễ bị trùng với 1 từ khóa/thẻ khác trong html
        -> Nên đặt từ 2 từ trở lên
    TodoListTable.vue
      https://getbootstrap.com/docs/4.3/migration/#panels
      panel là 1 class của Bootstrap 3 sang Bootstrap 4 nó được chuyển đổi thành card
    <div class="container"> Thay thế bằng b-container
    <div class="row"> 
      Thay thế bằng b-row
    <div class="col-12 col-lg-6">
      Thay thế bằng <b-col cols="12" lg="6">
  
Hiển thị danh sách Task Items (Mock data, uuid)
  Mock data trong App Component rồi sử dụng props để truyền vào các Component bên trong đó là TodoListTable
  Khi hiển thị level thì ngoài vấn đề liên quan đến đoạn text thì còn có liên quan đến class mỗi level sẽ có 1 màu khác nhau
    Keywords: bootstrap 4 -> badge
  Hiện tại thì không cần quan tâm đến việc lưu dữ liệu -> Tạo mock data các data này thì mình tạo ra các file mới để cho dễ quản lý, ở đây thì
    các file mock này mình quản lý trong thư mục mocks
    Dùng các kiến thức của ES6 để tách file thông qua các từ khóa như import, export
  Sử dụng các thư viện hỗ trợ để sinh ra các id ngẫu nhiên
    Đây là 1 thư viện của nodeJs
    Keywords: uuid npm
    https://www.npmjs.com/package/uuid
    Cài đặt: npm i uuid
      const uuidv4 = require('uuid/v4');
      uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
  Tạo dữ liệu mock cho level
    { 
        name: 'Small',
        class: 'badge-info'
    }
    return this.mapLevel[this.task.level].class;
    Lúc này computed classLevel trả về class là 1 chuỗi, cũng không nhất thiết phải là 1 object

Chức năng Form Toggle
  Đối với Form nhập liệu thì mình sẽ cho ẩn đi, khi mà người dùng load lại trang lần đầu tiên hoặc là truy cập vào ứng 
    dụng lần đầu tiên thì Form được ẩn đi
  Trước khi thực hiện logic liên quan đến sự kiện thì mình tạo ra dữ liệu giúp nhận diện khi nào Form đó được ẩn và khi
    nào thì được hiện
  Form chỉ có 2 trạng thái hoặc là ẩn hoặc là hiển nên có thể sử dụng 1 biến Boolean có giá trị là true/false để quy định 
    việc này
  Bắt sự kiện click vào Add Task, sau khi click thì thay đổi data để ẩn hoặc hiện Form
  App
    CompForm
      FormAdd -> Click 
          -> Run onClickAddTask() 
          -> Kích hoạt Event handleAddTask 
          -> Kích hoạt tiếp toggleForm -> Tiến hành thay đổi giá trị isShowForm để ẩn hiện Form
  Khi Form đang được ẩn đi thì tiến nút hiện lên là Add Task, khi Form hiện lên thì thay thế nút này thành 1 nút khác chẳng 
    hạn như là Close Form
  Khi nhấn vào nút Cancel thì cũng hủy luôn Form -> Ẩn Form
    <button v-on:click="$emit('toggleForm')" type="button" class="btn btn-secondary">Cancel</button>

Xây dựng chức năng Search
  Thực hiện gõ tới đâu thì Search tới đó luôn
  Str Search: Ràng buộc dữ liệu 2 chiều từ việc thu thập dữ liệu từ người dùng
    Chuyển đổi dạng v-model thành mô hình v-bind kết hợp với v-on:input/change
    App -> CompControl -> ControlSearch
  Clear Search: Sau khi nhập vào ô input tìm kiếm rồi sau đó nhấn vào nút clear thì sẽ thay đổi giá trị strSearch thành giá trị rỗng
  Logic Search: Sau khi đã lấy được dữ liệu thu thập từ người dùng, dùng giá trị đó để thực hiện logic tính toán
    Đối Vuejs thì chỉ cần tập trung vào phần logic của method xử lý thôi, không cần quan tấm đến cấu trúc DOM nữa bởi vì hệ thống phản
      ứng sẽ tự động Render lại
    Tạo 1 computed thực hiện tính toán lại theo logic tìm kiếm của mình rồi sau đó truyền vào TodoListTable giá trị sau khi mình đã lọc
    Tiến hành tìm kiếm bằng cách tìm xem strSearch có tồn tại trong bất kỳ item nào hay không
    Keywords: how to Search string in another string Javascript
   Search Lowercase: Giải quyết vấn đề không tìm kiếm được các dạng chữ hoa, chữ thườngSearch Lowercase: Giải quyết vấn đề không tìm kiếm được các dạng chữ hoa, chữ thường
    Chuyển đổi hết về chữ thường 
    Keywords: Lowercase Javascript
    Khi thực hiện tìm kiếm mà không có kết quả trả về thì hiển thị lên 1 dòng chữ là List Empty, dùng colspan để merge các col thành 1
      <td colspan="4">List Empty</td> 
  Optimize Code:
    Sử dụng filter() thay cho foreach khi thực hiện tìm kiếm

Xây dựng chức năng Sort
  Có 4 cách sắp xếp: Name asc, Name desc, Level asc, Level desc
  Props Sort
    Dùng Css để hiển thị text bằng chữ in hoa
      .order {
          text-transform: uppercase
      }
  Event Up
    Sau khi nhận được sự kiện Click và lấy được tham số tương ứng thì tiếp tục sử dụng Event up để truyền sự kiện từ Component con ra 
      Component cha
  Method Sort: Thực hiện logic liên quan đến sắp xếp(Sắp xếp array)
    Keywords: sort Javascript
    https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
    Đối với phương thức sort() thì khi không truyền gì cả thì mặc định nó sẽ hiểu là so sánh chuỗi
      Khi sort đối với number
        function compareNumbers(a, b) {
          return a - b;
        }
      Khi sort đối với string -> Phải sử dụng if-else
        function compare(a, b) {
          if (a is less than b by some ordering criterion) {
            return -1;
          }
          if (a is greater than b by the ordering criterion) {
            return 1;
          }
          // a must be equal to b
          return 0;
        }
  Handle Sort: Áp dụng hàm sort của array để giải quyết bài toán
    Có 2 yếu tố cần sắp xếp đó là name và level, tương ứng với 2 yếu tố này thì cần có 2 hàm compare dành cho name và level
    compareName(): Việc sắp xếp theo tên thì việc return -1 hay 1 còn phụ thuộc vào asc hay desc
    listTaskSort(): Cần xác định là khi nào là sort theo level và khi nào là sort theo name
    Thực hiện kết nối Sort và Search: Thực hiện Search trước rồi mới Sort tức là thay vì Sort dựa trên mảng gốc thì mình sẽ sắp xếp
      dựa trên giá trị mà người dùng đã Search
  Optimize Code: Tối ưu hóa mã nguồn phần sort theo name và level

Xây dựng chức năng Delete: Xây dụng chức năng xóa 1 phần tử bất kỳ trong List Items
  Handle Event:
    Trước khi thực hiện delete thì cho hiển thị lên 1 câu thông báo để tránh xảy ra việc người dùng xóa nhầm -> Trước khi thực hiện 
      kích hoạt sự kiện ra bên ngoài ở TodoList thì gọi ra 1 câu thông báo
  Methods Delete: Tìm hiểu việc xóa 1 phần tử từ trong Array theo 1 điều kiện nào đó
    Keywords: remove element from array JavaScript, splice JavaScript
    splice - removes from a specific Array index -> Để thực hiện được thì cần biết được index của phần tử -> return về phần tử sau 
      khi xóa, làm thay đổi luôn mảng gốc
    filter - allows you to programatically remove elements from an Array ->return về mảng sau khi xóa, không làm thay đổi mảng gốc
  Handle Delete: Tiến hành delete dữ liệu thông qua hàm filter

Xây dựng chức năng Add New Task: Thêm mới 1 phần tử vào trong task
  Cần lấy được data mà người dùng nhập vào Form, Khi người dùng nhấn vào nút Submit thì lấy dữ liệu mà người dùng vừa nhập truyền ra
    bên ngoài và tiến hành thêm mới vào array
  Khi nhấn vào nút Submit xong thì ẩn Form đi, Reset lại dữ liệu

Xây dựng chức năng Edit
  Event Up:
    Khi nhấn vào nút Edit thì cần truyền được task ra bên ngoài để App có thể nhận diện được mình Edit task nào
    Có sự tương tác giữa 2 Component khác nhau, không chỉ đơn thuần là truyền ra App mà mình cũng cần phải truyền qua Form vì khi Người
      dùng Click vào Edit thì cần lấy được dữ liệu của task đó truyền lên Form để show ra Form cho người dùng -> Them data mới là taskSelected
    Form cần nhận diện được khi nào Add và khi nào là Edit
    taskSelected khác null thì có nghĩa là người dùng đang tiến hành Edit, bằng null thì là Add